"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[2431],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),d=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=d(e.components);return i.createElement(s.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=d(t),m=a,h=p["".concat(s,".").concat(m)]||p[m]||u[m]||o;return t?i.createElement(h,l(l({ref:n},c),{},{components:t})):i.createElement(h,l({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=m;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[p]="string"==typeof e?e:a,l[1]=r;for(var d=2;d<o;d++)l[d]=t[d];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8026:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var i=t(7462),a=(t(7294),t(3905));const o={layout:"docs",title:"Hierarchy Cookbook",section:"chisel3"},l="Hierarchy Cookbook",r={unversionedId:"cookbooks/hierarchy",id:"cookbooks/hierarchy",title:"Hierarchy Cookbook",description:"* How do I instantiate multiple instances with the same module parameterization, but avoid re-elaboration?",source:"@site/docs/cookbooks/hierarchy.md",sourceDirName:"cookbooks",slug:"/cookbooks/hierarchy",permalink:"/chisel/docs/cookbooks/hierarchy",draft:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/cookbooks/hierarchy.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Hierarchy Cookbook",section:"chisel3"},sidebar:"tutorialSidebar",previous:{title:"DataView Cookbook",permalink:"/chisel/docs/cookbooks/dataview"},next:{title:"Naming Cookbook",permalink:"/chisel/docs/cookbooks/naming"}},s={},d=[{value:"How do I instantiate multiple instances with the same module parameterization?",id:"how-do-i-instantiate-multiple-instances-with-the-same-module-parameterization",level:2},{value:"Using Definition and Instance",id:"using-definition-and-instance",level:3},{value:"Using Instantiate",id:"using-instantiate",level:3},{value:"How do I access internal fields of an instance?",id:"how-do-i-access-internal-fields-of-an-instance",level:2},{value:"How do I make my parameters accessible from an instance?",id:"how-do-i-make-my-parameters-accessible-from-an-instance",level:2},{value:"How do I look up parameters from a Definition, if I don&#39;t want to instantiate it?",id:"how-do-i-look-up-parameters-from-a-definition-if-i-dont-want-to-instantiate-it",level:2},{value:"How do I parameterize a module by its children instances?",id:"how-do-i-parameterize-a-module-by-its-children-instances",level:2},{value:"How do I use the new hierarchy-specific Select functions?",id:"how-do-i-use-the-new-hierarchy-specific-select-functions",level:2}],c={toc:d},p="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,i.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"hierarchy-cookbook"},"Hierarchy Cookbook"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#how-do-i-instantiate-multiple-instances-with-the-same-module-parameterization"},"How do I instantiate multiple instances with the same module parameterization, but avoid re-elaboration?")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#how-do-i-access-internal-fields-of-an-instance"},"How do I access internal fields of an instance?")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#how-do-i-make-my-parameters-accessable-from-an-instance"},"How do I make my parameters accessable from an instance?")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#how-do-i-reuse-a-previously-elaborated-module-if-my-new-module-has-the-same-parameterization"},"How do I reuse a previously elaborated module, if my new module has the same parameterization?")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#how-do-I-parameterize-a-module-by-its-children-instances"},"How do I parameterize a module by its children instances?")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#how-do-I-use-the-new-hierarchy-specific-Select-functions"},"How do I use the new hierarchy-specific Select functions?"))),(0,a.kt)("h2",{id:"how-do-i-instantiate-multiple-instances-with-the-same-module-parameterization"},"How do I instantiate multiple instances with the same module parameterization?"),(0,a.kt)("p",null,'Prior to this package, Chisel users relied on deduplication in a FIRRTL compiler to combine\nstructurally equivalent modules into one module (aka "deduplication").\nThis package introduces the following new APIs to enable multiply-instantiated modules directly in Chisel.'),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Definition(...)")," enables elaborating a module, but does not actually instantiate that module.\nInstead, it returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"Definition")," class which represents that module's definition."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Instance(...)")," takes a ",(0,a.kt)("inlineCode",{parentName:"p"},"Definition")," and instantiates it, returning an ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance")," object."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Instantiate(...)")," provides an API similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"Module(...)"),", except it uses\n",(0,a.kt)("inlineCode",{parentName:"p"},"Definition")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance")," to only elaborate modules once for a given set of\nparameters. It returns an ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance")," object."),(0,a.kt)("p",null,"Modules (classes or traits) which will be used with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Definition"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"Instance")," api should be marked\nwith the ",(0,a.kt)("inlineCode",{parentName:"p"},"@instantiable")," annotation at the class/trait definition."),(0,a.kt)("p",null,"To make a Module's members variables accessible from an ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance")," object, they must be annotated\nwith the ",(0,a.kt)("inlineCode",{parentName:"p"},"@public")," annotation. Note that this is only accessible from a Scala sense\u2014this is not\nin and of itself a mechanism for cross-module references."),(0,a.kt)("h3",{id:"using-definition-and-instance"},"Using Definition and Instance"),(0,a.kt)("p",null,"In the following example, use ",(0,a.kt)("inlineCode",{parentName:"p"},"Definition"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@instantiable")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"@public")," to create\nmultiple instances of one specific parameterization of a module, ",(0,a.kt)("inlineCode",{parentName:"p"},"AddOne"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nimport chisel3.experimental.hierarchy.{Definition, Instance, instantiable, public}\n\n@instantiable\nclass AddOne(width: Int) extends Module {\n  @public val in  = IO(Input(UInt(width.W)))\n  @public val out = IO(Output(UInt(width.W)))\n  out := in + 1.U\n}\n\nclass AddTwo(width: Int) extends Module {\n  val in  = IO(Input(UInt(width.W)))\n  val out = IO(Output(UInt(width.W)))\n  val addOneDef = Definition(new AddOne(width))\n  val i0 = Instance(addOneDef)\n  val i1 = Instance(addOneDef)\n  i0.in := in\n  i1.in := i0.out\n  out   := i1.out\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule AddOne(  // <stdin>:3:3\n  input  [9:0] in,  // hierarchy.md:16:23\n  output [9:0] out  // hierarchy.md:17:23\n);\n\n  assign out = in + 10'h1;  // <stdin>:3:3, hierarchy.md:18:13\nendmodule\n\nmodule AddTwo(  // <stdin>:13:3\n  input        clock,   // <stdin>:14:11\n               reset,   // <stdin>:15:11\n  input  [9:0] in,  // hierarchy.md:23:15\n  output [9:0] out  // hierarchy.md:24:15\n);\n\n  wire [9:0] _i0_out;   // hierarchy.md:26:20\n  AddOne i0 (   // hierarchy.md:26:20\n    .in  (in),\n    .out (_i0_out)\n  );\n  AddOne i1 (   // hierarchy.md:27:20\n    .in  (_i0_out), // hierarchy.md:26:20\n    .out (out)\n  );\nendmodule\n\n")),(0,a.kt)("h3",{id:"using-instantiate"},"Using Instantiate"),(0,a.kt)("p",null,"Similar to the above, the following example uses ",(0,a.kt)("inlineCode",{parentName:"p"},"Instantiate")," to create\nmultiple instances of ",(0,a.kt)("inlineCode",{parentName:"p"},"AddOne"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3.experimental.hierarchy.Instantiate\n\nclass AddTwoInstantiate(width: Int) extends Module {\n  val in  = IO(Input(UInt(width.W)))\n  val out = IO(Output(UInt(width.W)))\n  val i0 = Instantiate(new AddOne(width))\n  val i1 = Instantiate(new AddOne(width))\n  i0.in := in\n  i1.in := i0.out\n  out   := i1.out\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule AddOne(  // <stdin>:3:3\n  input  [15:0] in, // hierarchy.md:16:23\n  output [15:0] out // hierarchy.md:17:23\n);\n\n  assign out = in + 16'h1;  // <stdin>:3:3, hierarchy.md:18:13\nendmodule\n\nmodule AddTwoInstantiate(   // <stdin>:13:3\n  input         clock,  // <stdin>:14:11\n                reset,  // <stdin>:15:11\n  input  [15:0] in, // hierarchy.md:47:15\n  output [15:0] out // hierarchy.md:48:15\n);\n\n  wire [15:0] _i0_out;  // hierarchy.md:49:23\n  AddOne i0 (   // hierarchy.md:49:23\n    .in  (in),\n    .out (_i0_out)\n  );\n  AddOne i1 (   // hierarchy.md:50:23\n    .in  (_i0_out), // hierarchy.md:49:23\n    .out (out)\n  );\nendmodule\n\n")),(0,a.kt)("h2",{id:"how-do-i-access-internal-fields-of-an-instance"},"How do I access internal fields of an instance?"),(0,a.kt)("p",null,"You can mark internal members of a class or trait marked with ",(0,a.kt)("inlineCode",{parentName:"p"},"@instantiable")," with the ",(0,a.kt)("inlineCode",{parentName:"p"},"@public")," annotation.\nThe requirements are that the field is publicly accessible, is a ",(0,a.kt)("inlineCode",{parentName:"p"},"val")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"lazy val"),", and is a valid type.\nThe list of valid types are:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"IsInstantiable")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"IsLookupable")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Data")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"BaseModule")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Iterable"),"/",(0,a.kt)("inlineCode",{parentName:"li"},"Option "),"containing a type that meets these requirements"),(0,a.kt)("li",{parentName:"ol"},"Basic type like ",(0,a.kt)("inlineCode",{parentName:"li"},"String"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Int"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"BigInt")," etc.")),(0,a.kt)("p",null,"To mark a superclass's member as ",(0,a.kt)("inlineCode",{parentName:"p"},"@public"),", use the following pattern (shown with ",(0,a.kt)("inlineCode",{parentName:"p"},"val clock"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nimport chisel3.experimental.hierarchy.{instantiable, public}\n\n@instantiable\nclass MyModule extends Module {\n  @public val clock = clock\n}\n")),(0,a.kt)("p",null,"You'll get the following error message for improperly marking something as ",(0,a.kt)("inlineCode",{parentName:"p"},"@public"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nimport chisel3.experimental.hierarchy.{instantiable, public}\n\nobject NotValidType\n\n@instantiable\nclass MyModule extends Module {\n  @public val x = NotValidType\n}\n// error: @public is only legal within a class or trait marked @instantiable, and only on vals of type Data, BaseModule, MemBase, IsInstantiable, IsLookupable, or Instance[_], or in an Iterable, Option, Either, or Tuple2\n// val x = circt.stage.ChiselStage.emitCHIRRTL(new Top)\n//     ^\n")),(0,a.kt)("h2",{id:"how-do-i-make-my-parameters-accessible-from-an-instance"},"How do I make my parameters accessible from an instance?"),(0,a.kt)("p",null,"If an instance's parameters are simple (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"Int"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," etc.) they can be marked directly with ",(0,a.kt)("inlineCode",{parentName:"p"},"@public"),"."),(0,a.kt)("p",null,"Often, parameters are more complicated and are contained in case classes.\nIn such cases, mark the case class with the ",(0,a.kt)("inlineCode",{parentName:"p"},"IsLookupable")," trait.\nThis indicates to Chisel that instances of the ",(0,a.kt)("inlineCode",{parentName:"p"},"IsLookupable")," class may be accessed from within instances."),(0,a.kt)("p",null,"However, ensure that these parameters are true for ",(0,a.kt)("strong",{parentName:"p"},"all")," instances of a definition.\nFor example, if our parameters contained an id field which was instance-specific but defaulted to zero,\nthen the definition's id would be returned for all instances.\nThis change in behavior could lead to bugs if other code presumed the id field was correct."),(0,a.kt)("p",null,"Thus, it is important that when converting normal modules to use this package,\nyou are careful about what you mark as ",(0,a.kt)("inlineCode",{parentName:"p"},"IsLookupable"),"."),(0,a.kt)("p",null,"In the following example, we added the trait ",(0,a.kt)("inlineCode",{parentName:"p"},"IsLookupable")," to allow the member to be marked ",(0,a.kt)("inlineCode",{parentName:"p"},"@public"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import chisel3._\nimport chisel3.experimental.hierarchy.{Definition, Instance, instantiable, IsLookupable, public}\n\ncase class MyCaseClass(width: Int) extends IsLookupable\n\n@instantiable\nclass MyModule extends Module {\n  @public val x = MyCaseClass(10)\n}\n\nclass Top extends Module {\n  val inst = Instance(Definition(new MyModule))\n  println(s"Width is ${inst.x.width}")\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Width is 10\nCircuit(Top,List(DefModule(repl.MdocSession$MdocApp5$MyModule@16f93311,MyModule,List(Port(MyModule.clock: IO[Clock],Input,UnlocatableSourceInfo), Port(MyModule.reset: IO[Reset],Input,UnlocatableSourceInfo)),Vector()), DefModule(repl.MdocSession$MdocApp5$Top@5f9883d4,Top,List(Port(Top.clock: IO[Clock],Input,UnlocatableSourceInfo), Port(Top.reset: IO[Bool],Input,UnlocatableSourceInfo)),Vector(DefInstance(SourceLine(hierarchy.md,112,22),ModuleClone(repl.MdocSession$MdocApp5$MyModule@16f93311),List(Port(MyModule.clock: IO[Clock],Input,UnlocatableSourceInfo), Port(MyModule.reset: IO[Reset],Input,UnlocatableSourceInfo))), Connect(SourceLine(hierarchy.md,112,22),Node(MyModule.inst.clock: IO[Clock]),Node(Top.clock: IO[Clock])), Connect(SourceLine(hierarchy.md,112,22),Node(MyModule.inst.reset: IO[Reset]),Node(Top.reset: IO[Bool]))))),List(),firrtl.renamemap.package$MutableRenameMap@629c0a20,List(),List(),List())\n")),(0,a.kt)("h2",{id:"how-do-i-look-up-parameters-from-a-definition-if-i-dont-want-to-instantiate-it"},"How do I look up parameters from a Definition, if I don't want to instantiate it?"),(0,a.kt)("p",null,"Just like ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance"),"s, ",(0,a.kt)("inlineCode",{parentName:"p"},"Definition"),"'s also contain accessors for ",(0,a.kt)("inlineCode",{parentName:"p"},"@public")," members.\nAs such, you can directly access them:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import chisel3._\nimport chisel3.experimental.hierarchy.{Definition, instantiable, public}\n\n@instantiable\nclass AddOne(val width: Int) extends RawModule {\n  @public val width = width\n  @public val in  = IO(Input(UInt(width.W)))\n  @public val out = IO(Output(UInt(width.W)))\n  out := in + 1.U\n}\n\nclass Top extends Module {\n  val definition = Definition(new AddOne(10))\n  println(s"Width is: ${definition.width}")\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule Top( // <stdin>:11:3\n  input clock,  // <stdin>:12:11\n        reset   // <stdin>:13:11\n);\n\nendmodule\n\n")),(0,a.kt)("h2",{id:"how-do-i-parameterize-a-module-by-its-children-instances"},"How do I parameterize a module by its children instances?"),(0,a.kt)("p",null,"Prior to the introduction of this package, a parent module would have to pass all necessary parameters\nwhen instantiating a child module.\nThis had the unfortunate consequence of requiring a parent's parameters to always contain the child's\nparameters, which was an unnecessary coupling which lead to some anti-patterns."),(0,a.kt)("p",null,"Now, a parent can take a child ",(0,a.kt)("inlineCode",{parentName:"p"},"Definition")," as an argument, and instantiate it directly.\nIn addition, it can analyze the parameters used in the definition to parameterize itself.\nIn a sense, now the child can actually parameterize the parent."),(0,a.kt)("p",null,"In the following example, we create a definition of ",(0,a.kt)("inlineCode",{parentName:"p"},"AddOne"),", and pass the definition to ",(0,a.kt)("inlineCode",{parentName:"p"},"AddTwo"),".\nThe width of the ",(0,a.kt)("inlineCode",{parentName:"p"},"AddTwo")," ports are now derived from the parameterization of the ",(0,a.kt)("inlineCode",{parentName:"p"},"AddOne")," instance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nimport chisel3.experimental.hierarchy.{Definition, Instance, instantiable, public}\n\n@instantiable\nclass AddOne(val width: Int) extends Module {\n  @public val width = width\n  @public val in  = IO(Input(UInt(width.W)))\n  @public val out = IO(Output(UInt(width.W)))\n  out := in + 1.U\n}\n\nclass AddTwo(addOneDef: Definition[AddOne]) extends Module {\n  val i0 = Instance(addOneDef)\n  val i1 = Instance(addOneDef)\n  val in  = IO(Input(UInt(addOneDef.width.W)))\n  val out = IO(Output(UInt(addOneDef.width.W)))\n  i0.in := in\n  i1.in := i0.out\n  out   := i1.out\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule AddOne(  // <stdin>:3:3\n  input  [9:0] in,  // hierarchy.md:184:23\n  output [9:0] out  // hierarchy.md:185:23\n);\n\n  assign out = in + 10'h1;  // <stdin>:3:3, hierarchy.md:186:13\nendmodule\n\nmodule AddTwo(  // <stdin>:13:3\n  input        clock,   // <stdin>:14:11\n               reset,   // <stdin>:15:11\n  input  [9:0] in,  // hierarchy.md:193:15\n  output [9:0] out  // hierarchy.md:194:15\n);\n\n  wire [9:0] _i0_out;   // hierarchy.md:191:20\n  AddOne i0 (   // hierarchy.md:191:20\n    .in  (in),\n    .out (_i0_out)\n  );\n  AddOne i1 (   // hierarchy.md:192:20\n    .in  (_i0_out), // hierarchy.md:191:20\n    .out (out)\n  );\nendmodule\n\n")),(0,a.kt)("h2",{id:"how-do-i-use-the-new-hierarchy-specific-select-functions"},"How do I use the new hierarchy-specific Select functions?"),(0,a.kt)("p",null,"Select functions can be applied after a module has been elaborated, either in a Chisel Aspect or in a parent module applied to a child module."),(0,a.kt)("p",null,"There are seven hierarchy-specific functions, which (with the exception of ",(0,a.kt)("inlineCode",{parentName:"p"},"ios"),") either return ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance"),"'s or ",(0,a.kt)("inlineCode",{parentName:"p"},"Definition"),"'s:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"instancesIn(parent)"),": Return all instances directly instantiated locally within ",(0,a.kt)("inlineCode",{parentName:"li"},"parent")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"instancesOf[type](parent)"),": Return all instances of provided ",(0,a.kt)("inlineCode",{parentName:"li"},"type")," directly instantiated locally within ",(0,a.kt)("inlineCode",{parentName:"li"},"parent")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"allInstancesOf[type](root)"),": Return all instances of provided ",(0,a.kt)("inlineCode",{parentName:"li"},"type")," directly and indirectly instantiated, locally and deeply, starting from ",(0,a.kt)("inlineCode",{parentName:"li"},"root")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"definitionsIn"),": Return definitions of all instances directly instantiated locally within ",(0,a.kt)("inlineCode",{parentName:"li"},"parent")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"definitionsOf[type]"),": Return definitions of all instances of provided ",(0,a.kt)("inlineCode",{parentName:"li"},"type")," directly instantiated locally within ",(0,a.kt)("inlineCode",{parentName:"li"},"parent")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"allDefinitionsOf[type]"),": Return all definitions of instances of provided ",(0,a.kt)("inlineCode",{parentName:"li"},"type")," directly and indirectly instantiated, locally and deeply, starting from ",(0,a.kt)("inlineCode",{parentName:"li"},"root")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ios"),": Returns all the I/Os of the provided definition or instance.")),(0,a.kt)("p",null,"To demonstrate this, consider the following. We mock up an example where we are using the ",(0,a.kt)("inlineCode",{parentName:"p"},"Select.allInstancesOf")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Select.allDefinitionsOf")," to annotate instances and the definition of ",(0,a.kt)("inlineCode",{parentName:"p"},"EmptyModule"),". When converting the ",(0,a.kt)("inlineCode",{parentName:"p"},"ChiselAnnotation")," to firrtl's ",(0,a.kt)("inlineCode",{parentName:"p"},"Annotation"),", we print out the resulting ",(0,a.kt)("inlineCode",{parentName:"p"},"Target"),". As shown, despite ",(0,a.kt)("inlineCode",{parentName:"p"},"EmptyModule")," actually only being elaborated once, we still provide different targets depending on how the instance or definition is selected."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import chisel3._\nimport chisel3.experimental.hierarchy.{Definition, Instance, Hierarchy, instantiable, public}\nimport firrtl.annotations.{IsModule, NoTargetAnnotation}\ncase object EmptyAnnotation extends NoTargetAnnotation\ncase class MyChiselAnnotation(m: Hierarchy[RawModule], tag: String) extends experimental.ChiselAnnotation {\n  def toFirrtl = {\n    println(tag + ": " + m.toTarget)\n    EmptyAnnotation\n  }\n}\n\n@instantiable\nclass EmptyModule extends Module {\n  println("Elaborating EmptyModule!")\n}\n\n@instantiable\nclass TwoEmptyModules extends Module {\n  val definition = Definition(new EmptyModule)\n  val i0         = Instance(definition)\n  val i1         = Instance(definition)\n}\n\nclass Top extends Module {\n  val definition = Definition(new TwoEmptyModules)\n  val instance   = Instance(definition)\n  aop.Select.allInstancesOf[EmptyModule](instance).foreach { i =>\n    experimental.annotate(MyChiselAnnotation(i, "instance"))\n  }\n  aop.Select.allDefinitionsOf[EmptyModule](instance).foreach { d =>\n    experimental.annotate(MyChiselAnnotation(d, "definition"))\n  }\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Elaborating EmptyModule!\ninstance: ~Top|Top/instance:TwoEmptyModules/i0:EmptyModule\ninstance: ~Top|Top/instance:TwoEmptyModules/i1:EmptyModule\ndefinition: ~Top|EmptyModule\n")),(0,a.kt)("p",null,"You can also use ",(0,a.kt)("inlineCode",{parentName:"p"},"Select.ios")," on either a ",(0,a.kt)("inlineCode",{parentName:"p"},"Definition")," or an ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance")," to annotate the I/Os appropriately:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'case class MyIOAnnotation(m: Data, tag: String) extends experimental.ChiselAnnotation {\n  def toFirrtl = {\n    println(tag + ": " + m.toTarget)\n    EmptyAnnotation\n  }\n}\n\n@instantiable\nclass InOutModule extends Module {\n  @public val in = IO(Input(Bool()))\n  @public val out = IO(Output(Bool()))\n  out := in\n}\n\n@instantiable\nclass TwoInOutModules extends Module {\n  val in = IO(Input(Bool()))\n  val out = IO(Output(Bool()))\n  val definition = Definition(new InOutModule)\n  val i0         = Instance(definition)\n  val i1         = Instance(definition)\n  i0.in := in\n  i1.in := i0.out\n  out := i1.out\n}\n\nclass InOutTop extends Module {\n  val definition = Definition(new TwoInOutModules)\n  val instance   = Instance(definition)\n  aop.Select.allInstancesOf[InOutModule](instance).foreach { i =>\n    aop.Select.ios(i).foreach { io =>\n      experimental.annotate(MyIOAnnotation(io, "instance io"))\n  }}\n  aop.Select.allDefinitionsOf[InOutModule](instance).foreach { d =>\n    aop.Select.ios(d).foreach {io =>\n      experimental.annotate(MyIOAnnotation(io, "definition io"))\n  }}\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"instance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i0:InOutModule>clock\ninstance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i0:InOutModule>reset\ninstance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i0:InOutModule>in\ninstance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i0:InOutModule>out\ninstance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i1:InOutModule>clock\ninstance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i1:InOutModule>reset\ninstance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i1:InOutModule>in\ninstance io: ~InOutTop|InOutTop/instance:TwoInOutModules/i1:InOutModule>out\ndefinition io: ~InOutTop|InOutModule>clock\ndefinition io: ~InOutTop|InOutModule>reset\ndefinition io: ~InOutTop|InOutModule>in\ndefinition io: ~InOutTop|InOutModule>out\n")))}u.isMDXComponent=!0}}]);