"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[4485],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var u=a.createContext({}),r=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=r(e.components);return a.createElement(u.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,i=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=r(t),m=l,h=p["".concat(u,".").concat(m)]||p[m]||d[m]||i;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function h(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var u in n)hasOwnProperty.call(n,u)&&(s[u]=n[u]);s.originalType=e,s[p]="string"==typeof e?e:l,o[1]=s;for(var r=2;r<i;r++)o[r]=t[r];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2739:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>r});var a=t(7462),l=(t(7294),t(3905));const i={layout:"docs",title:"Enumerations",section:"chisel3"},o="ChiselEnum",s={unversionedId:"explanations/chisel-enum",id:"explanations/chisel-enum",title:"Enumerations",description:"The ChiselEnum type can be used to reduce the chance of error when encoding mux selectors, opcodes, and functional unit operations.",source:"@site/docs/explanations/chisel-enum.md",sourceDirName:"explanations",slug:"/explanations/chisel-enum",permalink:"/chisel/docs/explanations/chisel-enum",draft:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/chisel-enum.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Enumerations",section:"chisel3"},sidebar:"tutorialSidebar",previous:{title:"Bundles and Vecs",permalink:"/chisel/docs/explanations/bundles-and-vecs"},next:{title:"Chisel Type vs Scala Type",permalink:"/chisel/docs/explanations/chisel-type-vs-scala-type"}},u={},r=[{value:"Functionality and Examples",id:"functionality-and-examples",level:2},{value:"Casting",id:"casting",level:2},{value:"Testing",id:"testing",level:2},{value:"Workarounds",id:"workarounds",level:2},{value:"Additional Resources",id:"additional-resources",level:2}],c={toc:r},p="wrapper";function d(e){let{components:n,...t}=e;return(0,l.kt)(p,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"chiselenum"},"ChiselEnum"),(0,l.kt)("p",null,"The ChiselEnum type can be used to reduce the chance of error when encoding mux selectors, opcodes, and functional unit operations.\nIn contrast with ",(0,l.kt)("inlineCode",{parentName:"p"},"Chisel.util.Enum"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ChiselEnum")," are subclasses of ",(0,l.kt)("inlineCode",{parentName:"p"},"Data"),", which means that they can be used to define fields in ",(0,l.kt)("inlineCode",{parentName:"p"},"Bundle"),"s, including in ",(0,l.kt)("inlineCode",{parentName:"p"},"IO"),"s."),(0,l.kt)("h2",{id:"functionality-and-examples"},"Functionality and Examples"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"// Imports used in the following examples\nimport circt.stage.ChiselStage\nimport chisel3._\nimport chisel3.util._\n")),(0,l.kt)("p",null,"Below we see ChiselEnum being used as mux select for a RISC-V core. While wrapping the object in a package is not required, it is highly recommended as it allows for the type to be used in multiple files more easily."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"// package CPUTypes {\nobject AluMux1Sel extends ChiselEnum {\n  val selectRS1, selectPC = Value\n}\n// We can see the mapping by printing each Value\nAluMux1Sel.all.foreach(println)\n// AluMux1Sel(0=selectRS1)\n// AluMux1Sel(1=selectPC)\n")),(0,l.kt)("p",null,"Here we see a mux using the AluMux1Sel to select between different inputs."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"import AluMux1Sel._\n\nclass AluMux1Bundle extends Bundle {\n  val aluMux1Sel = Input(AluMux1Sel())\n  val rs1Out     = Input(Bits(32.W))\n  val pcOut      = Input(Bits(32.W))\n  val aluMux1Out = Output(Bits(32.W))\n}\n\nclass AluMux1File extends Module {\n  val io = IO(new AluMux1Bundle)\n\n  // Default value for aluMux1Out\n  io.aluMux1Out := 0.U\n\n  switch (io.aluMux1Sel) {\n    is (selectRS1) {\n      io.aluMux1Out := io.rs1Out\n    }\n    is (selectPC) {\n      io.aluMux1Out := io.pcOut\n    }\n  }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule AluMux1File( // <stdin>:17:3\n  input         clock,  // <stdin>:18:11\n                reset,  // <stdin>:19:11\n                io_aluMux1Sel,  // chisel-enum.md:63:14\n  input  [31:0] io_rs1Out,  // chisel-enum.md:63:14\n                io_pcOut,   // chisel-enum.md:63:14\n  output [31:0] io_aluMux1Out   // chisel-enum.md:63:14\n);\n\n  assign io_aluMux1Out = io_aluMux1Sel ? io_pcOut : io_rs1Out;  // <stdin>:17:3, chisel-enum.md:68:26, :70:21\nendmodule\n\n")),(0,l.kt)("p",null,"ChiselEnum also allows for the user to directly set the Values by passing an ",(0,l.kt)("inlineCode",{parentName:"p"},"UInt")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"Value(...)"),"\nas shown below. Note that the magnitude of each ",(0,l.kt)("inlineCode",{parentName:"p"},"Value")," must be strictly greater than the one before\nit."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object Opcode extends ChiselEnum {\n    val load  = Value(0x03.U) // i "load"  -> 000_0011\n    val imm   = Value(0x13.U) // i "imm"   -> 001_0011\n    val auipc = Value(0x17.U) // u "auipc" -> 001_0111\n    val store = Value(0x23.U) // s "store" -> 010_0011\n    val reg   = Value(0x33.U) // r "reg"   -> 011_0011\n    val lui   = Value(0x37.U) // u "lui"   -> 011_0111\n    val br    = Value(0x63.U) // b "br"    -> 110_0011\n    val jalr  = Value(0x67.U) // i "jalr"  -> 110_0111\n    val jal   = Value(0x6F.U) // j "jal"   -> 110_1111\n}\n')),(0,l.kt)("p",null,"The user can 'jump' to a value and continue incrementing by passing a start point then using a regular Value definition."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"object BranchFunct3 extends ChiselEnum {\n    val beq, bne = Value\n    val blt = Value(4.U)\n    val bge, bltu, bgeu = Value\n}\n// We can see the mapping by printing each Value\nBranchFunct3.all.foreach(println)\n// BranchFunct3(0=beq)\n// BranchFunct3(1=bne)\n// BranchFunct3(4=blt)\n// BranchFunct3(5=bge)\n// BranchFunct3(6=bltu)\n// BranchFunct3(7=bgeu)\n")),(0,l.kt)("h2",{id:"casting"},"Casting"),(0,l.kt)("p",null,"You can cast an enum to a ",(0,l.kt)("inlineCode",{parentName:"p"},"UInt")," using ",(0,l.kt)("inlineCode",{parentName:"p"},".asUInt"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"class ToUInt extends RawModule {\n  val in = IO(Input(Opcode()))\n  val out = IO(Output(UInt()))\n  out := in.asUInt\n}\n")),(0,l.kt)("p",null,"You can cast from a ",(0,l.kt)("inlineCode",{parentName:"p"},"UInt")," to an enum by passing the ",(0,l.kt)("inlineCode",{parentName:"p"},"UInt")," to the apply method of the ",(0,l.kt)("inlineCode",{parentName:"p"},"ChiselEnum")," object:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"class FromUInt extends Module {\n  val in = IO(Input(UInt(7.W)))\n  val out = IO(Output(Opcode()))\n  out := Opcode(in)\n}\n")),(0,l.kt)("p",null,"However, if you cast from a ",(0,l.kt)("inlineCode",{parentName:"p"},"UInt")," to an Enum type when there are undefined states in the Enum values\nthat the ",(0,l.kt)("inlineCode",{parentName:"p"},"UInt")," could hit, you will see a warning like the following:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"[\x1b[33mwarn\x1b[0m] chisel-enum.md 136:16: [W001] Casting non-literal UInt to repl.MdocSession$MdocApp$Opcode. You can use repl.MdocSession$MdocApp$Opcode.safe to cast without this warning.\n[\x1b[33mwarn\x1b[0m] There were \x1b[33m1 warning(s)\x1b[0m during hardware elaboration.\n")),(0,l.kt)("p",null,"(Note that the name of the Enum is ugly as an artifact of our documentation generation flow, it will\nbe cleaner in normal use)."),(0,l.kt)("p",null,"You can avoid this warning by using the ",(0,l.kt)("inlineCode",{parentName:"p"},".safe")," factory method which returns the cast Enum in addition\nto a ",(0,l.kt)("inlineCode",{parentName:"p"},"Bool")," indicating if the Enum is in a valid state:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'class SafeFromUInt extends Module {\n  val in = IO(Input(UInt(7.W)))\n  val out = IO(Output(Opcode()))\n  val (value, valid) = Opcode.safe(in)\n  assert(valid, "Enum state must be valid, got %d!", in)\n  out := value\n}\n')),(0,l.kt)("p",null,"Now there will be no warning:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"")),(0,l.kt)("p",null,"You can also suppress the warning by using ",(0,l.kt)("inlineCode",{parentName:"p"},"suppressEnumCastWarning"),". This is\nprimarily used for casting from [","[UInt]","] to a Bundle type that contains an\nEnum, where the [","[UInt]","] is known to be valid for the Bundle type."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"class MyBundle extends Bundle {\n  val addr = UInt(8.W)\n  val op = Opcode()\n}\n\nclass SuppressedFromUInt extends Module {\n  val in = IO(Input(UInt(15.W)))\n  val out = IO(Output(new MyBundle()))\n  suppressEnumCastWarning {\n    out := in.asTypeOf(new MyBundle)\n  }\n}\n")),(0,l.kt)("h2",{id:"testing"},"Testing"),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"Type")," of the enums values is ",(0,l.kt)("inlineCode",{parentName:"p"},"<ChiselEnum Object>.Type")," which can be useful for passing the values\nas parameters to a function (or any other time a type annotation is needed).\nCalling ",(0,l.kt)("inlineCode",{parentName:"p"},".litValue")," on an enum value will return the integer value of that object as a\n",(0,l.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/2.12.13/scala/math/BigInt.html"},(0,l.kt)("inlineCode",{parentName:"a"},"BigInt")),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"def expectedSel(sel: AluMux1Sel.Type): Boolean = sel match {\n  case AluMux1Sel.selectRS1 => (sel.litValue == 0)\n  case AluMux1Sel.selectPC  => (sel.litValue == 1)\n  case _                    => false\n}\n")),(0,l.kt)("p",null,"The enum value type also defines some convenience methods for working with ",(0,l.kt)("inlineCode",{parentName:"p"},"ChiselEnum")," values. For example, continuing with the RISC-V opcode\nexample, one could easily create hardware signal that is only asserted on LOAD/STORE operations (when the enum value is equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"Opcode.load"),"\nor ",(0,l.kt)("inlineCode",{parentName:"p"},"Opcode.store"),") using the ",(0,l.kt)("inlineCode",{parentName:"p"},".isOneOf")," method:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"class LoadStoreExample extends Module {\n  val io = IO(new Bundle {\n    val opcode = Input(Opcode())\n    val load_or_store = Output(Bool())\n  })\n  io.load_or_store := io.opcode.isOneOf(Opcode.load, Opcode.store)\n}\n")),(0,l.kt)("p",null,"Some additional useful methods defined on the ",(0,l.kt)("inlineCode",{parentName:"p"},"ChiselEnum")," object are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},".all"),": returns the enum values within the enumeration"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},".getWidth"),": returns the width of the hardware type")),(0,l.kt)("h2",{id:"workarounds"},"Workarounds"),(0,l.kt)("p",null,"As of Chisel v3.4.3 (1 July 2020), the width of the values is always inferred.\nTo work around this, you can add an extra ",(0,l.kt)("inlineCode",{parentName:"p"},"Value")," that forces the width that is desired.\nThis is shown in the example below, where we add a field ",(0,l.kt)("inlineCode",{parentName:"p"},"ukn")," to force the width to be 3 bits wide:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"object StoreFunct3 extends ChiselEnum {\n    val sb, sh, sw = Value\n    val ukn = Value(7.U)\n}\n// We can see the mapping by printing each Value\nStoreFunct3.all.foreach(println)\n// StoreFunct3(0=sb)\n// StoreFunct3(1=sh)\n// StoreFunct3(2=sw)\n// StoreFunct3(7=ukn)\n")),(0,l.kt)("p",null,"Signed values are not supported so if you want the value signed, you must cast the UInt with ",(0,l.kt)("inlineCode",{parentName:"p"},".asSInt"),"."),(0,l.kt)("h2",{id:"additional-resources"},"Additional Resources"),(0,l.kt)("p",null,"The ChiselEnum type is much more powerful than stated above. It allows for Sequence, Vec, and Bundle assignments, as well as a ",(0,l.kt)("inlineCode",{parentName:"p"},".next")," operation to allow for stepping through sequential states and an ",(0,l.kt)("inlineCode",{parentName:"p"},".isValid")," for checking that a hardware value is a valid ",(0,l.kt)("inlineCode",{parentName:"p"},"Value"),". The source code for the ChiselEnum can be found ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/chipsalliance/chisel3/blob/2a96767097264eade18ff26e1d8bce192383a190/core/src/main/scala/chisel3/StrongEnum.scala"},"here")," in the class ",(0,l.kt)("inlineCode",{parentName:"p"},"EnumFactory"),". Examples of the ChiselEnum operations can be found ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/chipsalliance/chisel3/blob/dd6871b8b3f2619178c2a333d9d6083805d99e16/src/test/scala/chiselTests/StrongEnum.scala"},"here"),"."))}d.isMDXComponent=!0}}]);