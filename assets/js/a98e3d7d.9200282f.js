"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[7219],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=d(n),u=r,h=p["".concat(s,".").concat(u)]||p[u]||c[u]||i;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1141:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const i={layout:"docs",title:"Memories",section:"chisel3"},o="Memories",l={unversionedId:"explanations/memories",id:"explanations/memories",title:"Memories",description:"Chisel provides facilities for creating both read only and read/write memories.",source:"@site/docs/explanations/memories.md",sourceDirName:"explanations",slug:"/explanations/memories",permalink:"/chisel/docs/explanations/memories",draft:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/memories.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Memories",section:"chisel3"},sidebar:"tutorialSidebar",previous:{title:"Intrinsics",permalink:"/chisel/docs/explanations/intrinsics"},next:{title:"Modules",permalink:"/chisel/docs/explanations/modules"}},s={},d=[{value:"ROM",id:"rom",level:2},{value:"Read-Write Memories",id:"read-write-memories",level:2},{value:"<code>SyncReadMem</code>: sequential/synchronous-read, sequential/synchronous-write",id:"syncreadmem-sequentialsynchronous-read-sequentialsynchronous-write",level:3},{value:"Read port/write port",id:"read-portwrite-port",level:4},{value:"Single-ported",id:"single-ported",level:4},{value:"<code>Mem</code>: combinational/asynchronous-read, sequential/synchronous-write",id:"mem-combinationalasynchronous-read-sequentialsynchronous-write",level:3},{value:"Masks",id:"masks",level:3},{value:"Memory Initialization",id:"memory-initialization",level:3},{value:"SRAM",id:"sram",level:2}],m={toc:d},p="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"memories"},"Memories"),(0,r.kt)("p",null,"Chisel provides facilities for creating both read only and read/write memories."),(0,r.kt)("h2",{id:"rom"},"ROM"),(0,r.kt)("p",null,"Users can define read-only memories by constructing a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"VecInit"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"VecInit")," can accept either a variable-argument number of ",(0,r.kt)("inlineCode",{parentName:"p"},"Data")," literals or a ",(0,r.kt)("inlineCode",{parentName:"p"},"Seq[Data]")," literals that initialize the ROM."),(0,r.kt)("p",null,"For example, users can create a small ROM initialized to 1, 2, 4, 8 and loop through all values using a counter as an address generator as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nimport chisel3.util.Counter\nval m = VecInit(1.U, 2.U, 4.U, 8.U)\nval c = Counter(m.length)\nc.inc()\nval r = m(c.value)\n")),(0,r.kt)("p",null,"We can create an ",(0,r.kt)("em",{parentName:"p"},"n")," value sine lookup table generator using a ROM initialized as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\n\nval Pi = math.Pi\ndef sinTable(amp: Double, n: Int) = {\n  val times =\n    (0 until n).map(i => (i*2*Pi)/(n.toDouble-1) - Pi)\n  val inits =\n    times.map(t => Math.round(amp * math.sin(t)).asSInt(32.W))\n  VecInit(inits)\n}\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"amp")," is used to scale the fixpoint values stored in the ROM."),(0,r.kt)("h2",{id:"read-write-memories"},"Read-Write Memories"),(0,r.kt)("p",null,"Memories are given special treatment in Chisel since hardware implementations of memory vary greatly. For example, FPGA memories are instantiated quite differently from ASIC memories. Chisel defines a memory abstraction that can map to either simple Verilog behavioural descriptions or to instances of memory modules that are available from external memory generators provided by foundry or IP vendors."),(0,r.kt)("h3",{id:"syncreadmem-sequentialsynchronous-read-sequentialsynchronous-write"},(0,r.kt)("inlineCode",{parentName:"h3"},"SyncReadMem"),": sequential/synchronous-read, sequential/synchronous-write"),(0,r.kt)("p",null,"Chisel has a construct called ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncReadMem")," for sequential/synchronous-read, sequential/synchronous-write memories. These ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncReadMem"),"s will likely be synthesized to technology SRAMs (as opposed to register banks)."),(0,r.kt)("p",null,"If the same memory address is both written and sequentially read on the same clock edge, or if a sequential read enable is cleared, then the read data is undefined."),(0,r.kt)("p",null,"Values on the read data port are not guaranteed to be held until the next read cycle. If that is the desired behavior, external logic to hold the last read value must be added."),(0,r.kt)("h4",{id:"read-portwrite-port"},"Read port/write port"),(0,r.kt)("p",null,"Ports into ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncReadMem"),"s are created by applying a ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt")," index.  A 1024-entry SRAM with one write port and one read port might be expressed as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nclass ReadWriteSmem extends Module {\n  val width: Int = 32\n  val io = IO(new Bundle {\n    val enable = Input(Bool())\n    val write = Input(Bool())\n    val addr = Input(UInt(10.W))\n    val dataIn = Input(UInt(width.W))\n    val dataOut = Output(UInt(width.W))\n  })\n\n  val mem = SyncReadMem(1024, UInt(width.W))\n  // Create one write port and one read port\n  mem.write(io.addr, io.dataIn)\n  io.dataOut := mem.read(io.addr, io.enable)\n}\n")),(0,r.kt)("p",null,"Below is an example waveform of the one write port/one read port ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncReadMem")," with ",(0,r.kt)("a",{parentName:"p",href:"#masks"},"masks"),". Note that the signal names will differ from the exact wire names generated for the ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncReadMem"),". With masking, it is also possible that multiple RTL arrays will be generated with the behavior below."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://svg.wavedrom.com/github/freechipsproject/www.chisel-lang.org/master/docs/src/main/resources/json/smem_read_write.json",alt:"read/write ports example waveform"}),"    "),(0,r.kt)("h4",{id:"single-ported"},"Single-ported"),(0,r.kt)("p",null,"Single-ported SRAMs can be inferred when the read and write conditions are mutually exclusive in the same ",(0,r.kt)("inlineCode",{parentName:"p"},"when")," chain:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nclass RWSmem extends Module {\n  val width: Int = 32\n  val io = IO(new Bundle {\n    val enable = Input(Bool())\n    val write = Input(Bool())\n    val addr = Input(UInt(10.W))\n    val dataIn = Input(UInt(width.W))\n    val dataOut = Output(UInt(width.W))\n  })\n\n  val mem = SyncReadMem(1024, UInt(width.W))\n  io.dataOut := DontCare\n  when(io.enable) {\n    val rdwrPort = mem(io.addr)\n    when (io.write) { rdwrPort := io.dataIn }\n      .otherwise    { io.dataOut := rdwrPort }\n  }\n}\n")),(0,r.kt)("p",null,"(The ",(0,r.kt)("inlineCode",{parentName:"p"},"DontCare")," is there to make Chisel's ",(0,r.kt)("a",{parentName:"p",href:"unconnected-wires"},"unconnected wire detection")," aware that reading while writing is undefined.)"),(0,r.kt)("p",null,"Here is an example single read/write port waveform, with ",(0,r.kt)("a",{parentName:"p",href:"#masks"},"masks")," (again, generated signal names and number of arrays may differ):"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://svg.wavedrom.com/github/freechipsproject/www.chisel-lang.org/master/docs/src/main/resources/json/smem_rw.json",alt:"read/write ports example waveform"})),(0,r.kt)("p",null,"Single-ported SRAMs can also be explicitly generated by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"readWrite")," call, which yields a single read/write accessor like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"class RDWR_Smem extends Module {\n  val width: Int = 32\n  val io = IO(new Bundle {\n    val enable = Input(Bool())\n    val write = Input(Bool())\n    val addr = Input(UInt(10.W))\n    val dataIn = Input(UInt(width.W))\n    val dataOut = Output(UInt(width.W))\n  })\n\n  val mem = SyncReadMem(1024, UInt(width.W))\n  io.dataOut := mem.readWrite(io.addr, io.dataIn, io.enable, io.write)\n}\n")),(0,r.kt)("h3",{id:"mem-combinationalasynchronous-read-sequentialsynchronous-write"},(0,r.kt)("inlineCode",{parentName:"h3"},"Mem"),": combinational/asynchronous-read, sequential/synchronous-write"),(0,r.kt)("p",null,"Chisel supports random-access memories via the ",(0,r.kt)("inlineCode",{parentName:"p"},"Mem")," construct. Writes to ",(0,r.kt)("inlineCode",{parentName:"p"},"Mem"),"s are combinational/asynchronous-read, sequential/synchronous-write. These ",(0,r.kt)("inlineCode",{parentName:"p"},"Mem"),"s will likely be synthesized to register banks, since most SRAMs in modern technologies (FPGA, ASIC) tend to no longer support combinational (asynchronous) reads."),(0,r.kt)("p",null,"Creating asynchronous-read versions of the examples above simply involves replacing ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncReadMem")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"Mem"),"."),(0,r.kt)("h3",{id:"masks"},"Masks"),(0,r.kt)("p",null,"Chisel memories also support write masks for subword writes. Chisel will infer masks if the data type of the memory is a vector. To infer a mask, specify the ",(0,r.kt)("inlineCode",{parentName:"p"},"mask")," argument of the ",(0,r.kt)("inlineCode",{parentName:"p"},"write")," function which creates write ports. A given masked length is written if the corresponding mask bit is set. For example, in the example below, if the 0th bit of mask is true, it will write the lower byte of the data at corresponding address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nclass MaskedReadWriteSmem extends Module {\n  val width: Int = 8\n  val io = IO(new Bundle {\n    val enable = Input(Bool())\n    val write = Input(Bool())\n    val addr = Input(UInt(10.W))\n    val mask = Input(Vec(4, Bool()))\n    val dataIn = Input(Vec(4, UInt(width.W)))\n    val dataOut = Output(Vec(4, UInt(width.W)))\n  })\n\n  // Create a 32-bit wide memory that is byte-masked\n  val mem = SyncReadMem(1024, Vec(4, UInt(width.W)))\n  // Write with mask\n  mem.write(io.addr, io.dataIn, io.mask)\n  io.dataOut := mem.read(io.addr, io.enable)\n}\n")),(0,r.kt)("p",null,"Here is an example of masks with readwrite ports:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3._\nclass MaskedRWSmem extends Module {\n  val width: Int = 32\n  val io = IO(new Bundle {\n    val enable = Input(Bool())\n    val write = Input(Bool())\n    val mask = Input(Vec(2, Bool()))\n    val addr = Input(UInt(10.W))\n    val dataIn = Input(Vec(2, UInt(width.W)))\n    val dataOut = Output(Vec(2, UInt(width.W)))\n  })\n\n  val mem = SyncReadMem(1024, Vec(2, UInt(width.W)))\n  io.dataOut := DontCare\n  when(io.enable) {\n    val rdwrPort = mem(io.addr)\n    when (io.write) {\n      when(io.mask(0)) {\n        rdwrPort(0) := io.dataIn(0)\n      }\n      when(io.mask(1)) {\n        rdwrPort(1) := io.dataIn(1)\n      }\n    }.otherwise { io.dataOut := rdwrPort }\n  }\n}\n")),(0,r.kt)("h3",{id:"memory-initialization"},"Memory Initialization"),(0,r.kt)("p",null,"Chisel memories can be initialized from an external ",(0,r.kt)("inlineCode",{parentName:"p"},"binary")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"hex")," file emitting proper Verilog for synthesis or simulation. There are multiple modes of initialization."),(0,r.kt)("p",null,"For more information, check the experimental docs on ",(0,r.kt)("a",{parentName:"p",href:"../appendix/experimental-features#loading-memories"},"Loading Memories")," feature."),(0,r.kt)("h2",{id:"sram"},"SRAM"),(0,r.kt)("p",null,"Chisel provides an API to generate ",(0,r.kt)("inlineCode",{parentName:"p"},"SRAMs"),", an alternative APIs for ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncReadMem"),"."),(0,r.kt)("p",null,"The key difference between the ",(0,r.kt)("inlineCode",{parentName:"p"},"SRAM")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncReadMem")," APIs is the former's capability to declare a specific number of read, write, and read-write memory ports, which are interacted with using explicit bundles."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3.util._\n\nclass ModuleWithSRAM(numReadPorts: Int, numWritePorts: Int, numReadwritePorts: Int) extends Module {\n  val width: Int = 8\n\n  val io = IO(new SRAMInterface(1024, UInt(width.W), numReadPorts, numWritePorts, numReadwritePorts))\n\n  // Generate a SyncReadMem representing an SRAM with an explicit number of read, write, and read-write ports\n  io :<>= SRAM(1024, UInt(width.W), numReadPorts, numWritePorts, numReadwritePorts)\n}\n")),(0,r.kt)("p",null,"To interact with a desired port, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"readPorts"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"writePorts"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"readwritePorts")," fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"class TopModule extends Module {\n  // Declare a 2 read, 2 write, 2 read-write ported SRAM with 8-bit UInt data members\n  val mem = SRAM(1024, UInt(8.W), 2, 2, 2)\n\n  // Whenever we want to read from the first read port\n  mem.readPorts(0).address := 100.U\n  mem.readPorts(0).enable := true.B\n\n  // Read data is returned one cycle after enable is driven\n  val foo = WireInit(UInt(8.W), mem.readPorts(0).data)\n\n  // Whenever we want to write to the second write port\n  mem.writePorts(1).address := 5.U\n  mem.writePorts(1).enable := true.B\n  mem.writePorts(1).data := 12.U\n\n  // Whenever we want to read or write to the third read-write port\n  // Write:\n  mem.readwritePorts(2).address := 5.U\n  mem.readwritePorts(2).enable := true.B\n  mem.readwritePorts(2).isWrite := true.B\n  mem.readwritePorts(2).writeData := 100.U\n\n  // Read:\n  mem.readwritePorts(2).address := 5.U\n  mem.readwritePorts(2).enable := true.B\n  mem.readwritePorts(2).isWrite := false.B\n  val bar = WireInit(UInt(8.W), mem.readwritePorts(2).readData)\n}\n")))}c.isMDXComponent=!0}}]);