"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[9837],{3905:(e,n,a)=>{a.d(n,{Zo:()=>p,kt:()=>h});var t=a(7294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function r(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),d=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},p=function(e){var n=d(e.components);return t.createElement(s.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=d(a),c=i,h=u["".concat(s,".").concat(c)]||u[c]||m[c]||l;return a?t.createElement(h,o(o({ref:n},p),{},{components:a})):t.createElement(h,o({ref:n},p))}));function h(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=a.length,o=new Array(l);o[0]=c;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:i,o[1]=r;for(var d=2;d<l;d++)o[d]=a[d];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"},370:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var t=a(7462),i=(a(7294),a(3905));const l={layout:"docs",title:"Naming Cookbook",section:"chisel3"},o="Naming Cookbook",r={unversionedId:"cookbooks/naming",id:"cookbooks/naming",title:"Naming Cookbook",description:"I still have _T signals, can this be fixed?",source:"@site/docs/cookbooks/naming.md",sourceDirName:"cookbooks",slug:"/cookbooks/naming",permalink:"/chisel/docs/cookbooks/naming",draft:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/cookbooks/naming.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Naming Cookbook",section:"chisel3"},sidebar:"tutorialSidebar",previous:{title:"Hierarchy Cookbook",permalink:"/chisel/docs/cookbooks/hierarchy"},next:{title:"Serialization Cookbook",permalink:"/chisel/docs/cookbooks/serialization"}},s={},d=[{value:"I still have _T signals, can this be fixed?",id:"i-still-have-_t-signals-can-this-be-fixed",level:3},{value:"I have so many wires with the same name, like <code>x</code>, <code>x_1</code> and <code>x_2</code>. How can I make them easier to understand?",id:"i-have-so-many-wires-with-the-same-name-like-x-x_1-and-x_2-how-can-i-make-them-easier-to-understand",level:3},{value:"How can I get better names for code generated by <code>when</code> clauses?",id:"how-can-i-get-better-names-for-code-generated-by-when-clauses",level:3},{value:"I still see _GEN signals, can this be fixed?",id:"i-still-see-_gen-signals-can-this-be-fixed",level:3},{value:"How do I make my modules have more stable names instead of &#39;Module_1&#39; and &#39;Module_42&#39;?",id:"how-do-i-make-my-modules-have-more-stable-names-instead-of-module_1-and-module_42",level:3},{value:"How would I write my own <code>typeName</code> for my data types?",id:"how-would-i-write-my-own-typename-for-my-data-types",level:3},{value:"I don&#39;t want to override <code>typeName</code> over and over! Is there any easy way to generate a <code>typeName</code>?",id:"i-dont-want-to-override-typename-over-and-over-is-there-any-easy-way-to-generate-a-typename",level:3},{value:"Can I name my bundles in FIRRTL, so I don&#39;t generate extremely long bundle types?",id:"can-i-name-my-bundles-in-firrtl-so-i-dont-generate-extremely-long-bundle-types",level:3},{value:"Why do I keep seeing _stripped suffixing everywhere in my FIRRTL? I didn&#39;t specify that in my <code>aliasName</code>.",id:"why-do-i-keep-seeing-_stripped-suffixing-everywhere-in-my-firrtl-i-didnt-specify-that-in-my-aliasname",level:3},{value:"I want to add some hardware or assertions, but each time I do all the signal names get bumped!",id:"i-want-to-add-some-hardware-or-assertions-but-each-time-i-do-all-the-signal-names-get-bumped",level:3},{value:"I want to force a signal (or instance) name to something, how do I do that?",id:"i-want-to-force-a-signal-or-instance-name-to-something-how-do-i-do-that",level:3},{value:"How can I omit the prefix in certain parts of the code?",id:"how-can-i-omit-the-prefix-in-certain-parts-of-the-code",level:3},{value:"I am still not getting the name I want. For example, inlining an instance changes my name!",id:"i-am-still-not-getting-the-name-i-want-for-example-inlining-an-instance-changes-my-name",level:3}],p={toc:d},u="wrapper";function m(e){let{components:n,...a}=e;return(0,i.kt)(u,(0,t.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"naming-cookbook"},"Naming Cookbook"),(0,i.kt)("h3",{id:"i-still-have-_t-signals-can-this-be-fixed"},"I still have _T signals, can this be fixed?"),(0,i.kt)("p",null,"See the next answer!"),(0,i.kt)("h3",{id:"i-have-so-many-wires-with-the-same-name-like-x-x_1-and-x_2-how-can-i-make-them-easier-to-understand"},"I have so many wires with the same name, like ",(0,i.kt)("inlineCode",{parentName:"h3"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"x_1")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"x_2"),". How can I make them easier to understand?"),(0,i.kt)("p",null,"Signals with ",(0,i.kt)("inlineCode",{parentName:"p"},"_T")," names or names that Chisel has to uniquify\noften are intermediate values generated within loops, function calls, or ",(0,i.kt)("inlineCode",{parentName:"p"},"when")," predicates.\nThey can also be consumed by verification statements like ",(0,i.kt)("inlineCode",{parentName:"p"},"assert")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"prints"),".\nIn these cases, the compiler plugin often can't find a good prefix for the generated\nintermediate signals and can't name them at all or has to make up a unique name for them."),(0,i.kt)("p",null,"We recommend you manually insert calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"prefix")," to clarify these cases:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import chisel3.experimental.prefix\nclass ExamplePrefix extends Module {\n\n  Seq.tabulate(2) { i =>\n    Seq.tabulate(2) { j =>\n      prefix(s"loop_${i}_${j}"){\n        val x = WireInit((i*0x10+j).U(8.W))\n        dontTouch(x)\n      }\n    }\n  }\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule ExamplePrefix(\n  input clock,\n        reset\n);\n\n  wire [7:0] loop_0_0_x = 8'h0;\n  wire [7:0] loop_0_1_x = 8'h1;\n  wire [7:0] loop_1_0_x = 8'h10;\n  wire [7:0] loop_1_1_x = 8'h11;\nendmodule\n\n")),(0,i.kt)("h3",{id:"how-can-i-get-better-names-for-code-generated-by-when-clauses"},"How can I get better names for code generated by ",(0,i.kt)("inlineCode",{parentName:"h3"},"when")," clauses?"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"prefix")," API can help with code inside ",(0,i.kt)("inlineCode",{parentName:"p"},"when")," clauses:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'class ExampleWhenPrefix extends Module {\n\n  val in = IO(Input(UInt(4.W)))\n  val out = IO(Output(UInt(4.W)))\n\n  out := DontCare\n\n  Seq.tabulate(2) { i =>\n    val j = i + 1\n    prefix(s"clause_${j}") {\n      when (in === j.U) {\n        val foo = Reg(UInt(4.W))\n        foo := in + j.U(4.W)\n        out := foo\n      }\n    }\n  }\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule ExampleWhenPrefix(\n  input        clock,\n               reset,\n  input  [3:0] in,\n  output [3:0] out\n);\n\n  reg [3:0] clause_1_foo;\n  reg [3:0] clause_2_foo;\n  always @(posedge clock) begin\n    clause_1_foo <= in + 4'h1;\n    clause_2_foo <= in + 4'h2;\n  end // always @(posedge)\n  assign out = in == 4'h2 ? clause_2_foo : clause_1_foo;\nendmodule\n\n")),(0,i.kt)("h3",{id:"i-still-see-_gen-signals-can-this-be-fixed"},"I still see _GEN signals, can this be fixed?"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"_GEN")," signals are usually generated from the FIRRTL compiler, rather than the Chisel library. We are working on\nrenaming these signals with more context-dependent names, but it is a work in progress. Thanks for caring!"),(0,i.kt)("h3",{id:"how-do-i-make-my-modules-have-more-stable-names-instead-of-module_1-and-module_42"},"How do I make my modules have more stable names instead of 'Module_1' and 'Module_42'?"),(0,i.kt)("p",null,"This is an example of the module instability problem, which results from several modules all sharing the exact same name. To fix this, you must add more specificity to your ",(0,i.kt)("inlineCode",{parentName:"p"},"Module"),"'s name to avoid these name collisions."),(0,i.kt)("p",null,"This can be done by leveraging the ",(0,i.kt)("inlineCode",{parentName:"p"},"desiredName")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName")," APIs.\n",(0,i.kt)("inlineCode",{parentName:"p"},"desiredName")," is for indicating the names of ",(0,i.kt)("inlineCode",{parentName:"p"},"Modules")," (e.g. influenced by the parameters passed in), and ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName")," is useful for modules which are type-parameterized by subclasses of ",(0,i.kt)("inlineCode",{parentName:"p"},"Data"),". Overriding ",(0,i.kt)("inlineCode",{parentName:"p"},"desiredName")," can reduce or even eliminate name collisions. For instance, suppose your module looks like the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class MyModule[T <: Data](gen: T) extends Module {\n  // ...\n}\n")),(0,i.kt)("p",null,"We can override ",(0,i.kt)("inlineCode",{parentName:"p"},"desiredName")," of the module to include the type name of the ",(0,i.kt)("inlineCode",{parentName:"p"},"gen")," parameter like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'class MyModule[T <: Data](gen: T) extends Module {\n  override def desiredName = s"MyModule_${gen.typeName}"\n}\n')),(0,i.kt)("p",null,"Any instances of your ",(0,i.kt)("inlineCode",{parentName:"p"},"MyModule")," will now have Verilog module names containing the type parameter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val foo = Module(new MyModule(UInt(4.W))) // MyModule_UInt4 // MyModule_UInt4\nval bar = Module(new MyModule(Vec(3, UInt(4.W)))) // MyModule_Vec3_UInt4\n")),(0,i.kt)("p",null,"Note that all base Chisel util modules, like ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue"),", already implement ",(0,i.kt)("inlineCode",{parentName:"p"},"desiredName")," like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val fooQueue = Module(new Queue(UInt(8.W), 4)) // Verilog module would be named 'Queue4_UInt8' // Verilog module would be named 'Queue4_UInt8'\nval barQueue = Module(new Queue(SInt(12.W), 3)) // ... and 'Queue3_SInt12' // ... and 'Queue3_SInt12'\nval bazQueue = Module(new Queue(Bool(), 16)) // ... and 'Queue16_Bool'\n")),(0,i.kt)("h3",{id:"how-would-i-write-my-own-typename-for-my-data-types"},"How would I write my own ",(0,i.kt)("inlineCode",{parentName:"h3"},"typeName")," for my data types?"),(0,i.kt)("p",null,"If you're using your own user-defined ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundle"),", you can increase the specificity of its own ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName")," by overriding it. All ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," types have a simple default implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName")," (which is simply its class name), but you can override this yourself:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class MyBundle[T <: Data](gen: T, intParam: Int) extends Bundle {\n  // Generate a stable typeName for this Bundle. Two 'words' are present\n  // in this implementation: the bundle's name plus its integer parameter\n  // (something like 'MyBundle9')\n  // and the generator's typeName, which itself can be composed of 'words'\n  // (something like 'Vec3_UInt4')\n  override def typeName = s\"MyBundle${intParam}_${gen.typeName}\"\n\n  // ...\n}\n")),(0,i.kt)("p",null,"Now if you use your ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBundle")," in a module like a ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val fooQueue = Module(new Queue(new MyBundle(UInt(4.W), 3), 16)) // Queue16_MyBundle3_UInt4\n")),(0,i.kt)("p",null,"The suggested pattern for ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName"),", and subsequently ",(0,i.kt)("inlineCode",{parentName:"p"},"desiredName"),", is to fold single integer-like parameters with the name itself (for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue4"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UInt3"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBundle9"),") to form 'words' and separate these 'words' with underscores (",(0,i.kt)("inlineCode",{parentName:"p"},"Queue4_UInt3"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FooBundle_BarType4"),")."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Bundles")," that have multiple integer arguments aren't presently addressed by any of the built-in modules, and so implementing a descriptive and sufficiently differentiable ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName")," for such ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundles")," is left as an exercise to the reader. However, integers should not occur with an underscore before them at the very end of the ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName")," (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBundle_1"),") because this is the ",(0,i.kt)("em",{parentName:"p"},"same")," syntax used for duplicates, and so would cause confusion. Having to disambiguate modules all named ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue32_MyBundle_4_1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue32_MyBundle_4_2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue32_MyBundle_4_3"),", and so on would be undesirable, indeed!"),(0,i.kt)("h3",{id:"i-dont-want-to-override-typename-over-and-over-is-there-any-easy-way-to-generate-a-typename"},"I don't want to override ",(0,i.kt)("inlineCode",{parentName:"h3"},"typeName")," over and over! Is there any easy way to generate a ",(0,i.kt)("inlineCode",{parentName:"h3"},"typeName"),"?"),(0,i.kt)("p",null,"Yes, with the experimental ",(0,i.kt)("inlineCode",{parentName:"p"},"HasAutoTypename")," trait. This trait can be mixed into your ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundle"),"s to automatically generate a tuple-like ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName")," for them, based on the constructor parameters of that ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundle"),". Let's look at the previous examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'class MyBundle[T <: Data](gen: T, intParam: Int) extends Bundle {\n  override def typeName = s"MyBundle_${gen.typeName}_${intParam}"\n  // ...\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'new MyBundle(UInt(8.W), 3).typeName\n// res7: String = "MyBundle_UInt<8>_3"\n')),(0,i.kt)("p",null,"Auto-generated ",(0,i.kt)("inlineCode",{parentName:"p"},"typeName"),"s take the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"{Bundle Name}_{Parameter Value 1}_{Parameter Value 2}_{...}"),", and so our ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBundle")," can be equivalently expressed with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3.experimental.HasAutoTypename\nclass MyBundle[T <: Data](gen: T, intParam: Int) extends Bundle with HasAutoTypename {\n  // ...\n  // Note: No `override def typeName` statement here\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'new MyBundle(UInt(8.W), 3).typeName\n// res9: String = "MyBundle_UInt<8>_3"\n')),(0,i.kt)("h3",{id:"can-i-name-my-bundles-in-firrtl-so-i-dont-generate-extremely-long-bundle-types"},"Can I name my bundles in FIRRTL, so I don't generate extremely long bundle types?"),(0,i.kt)("p",null,"Yes, using the ",(0,i.kt)("inlineCode",{parentName:"p"},"HasTypeAlias")," trait. FIRRTL has a construct to alias a bundle type with a type alias like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"circuit Top :\n  type MyBundle = { foo : UInt<8>, bar : UInt<1>}\n  \n  module Top :\n    //...\n")),(0,i.kt)("p",null,"These can be automatically emitted from Chisel by mixing ",(0,i.kt)("inlineCode",{parentName:"p"},"HasTypeAlias")," into a user-defined ",(0,i.kt)("inlineCode",{parentName:"p"},"Record"),", and implementing a field named ",(0,i.kt)("inlineCode",{parentName:"p"},"aliasName")," with a ",(0,i.kt)("inlineCode",{parentName:"p"},"RecordAlias(...)")," instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import chisel3.experimental.{HasTypeAlias, RecordAlias}\n\nclass AliasedBundle extends Bundle with HasTypeAlias {\n  override def aliasName = RecordAlias("MyAliasedBundle")\n  val foo = UInt(8.W)\n  val bar = Bool()\n}\n')),(0,i.kt)("p",null,"Let's see what happens when we generate FIRRTL using this ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundle"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'emitFIRRTL(new Module {\n  val wire = Wire(new AliasedBundle)\n})\n// res10: String = """FIRRTL version 3.3.0\n// circuit _18_Anon :\n//   type MyAliasedBundle = { foo : UInt<8>, bar : UInt<1>}\n// \n//   module _18_Anon :\n//     input clock : Clock\n//     input reset : UInt<1>\n// \n//     wire wire : MyAliasedBundle @[naming.md 253:18]\n// \n// """\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HasTypeAlias")," also supports nested bundles, too:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'class Child extends Bundle with HasTypeAlias {\n  override def aliasName = RecordAlias("ChildBundle")\n  val x = UInt(8.W)\n}\n\nclass Parent extends Bundle with HasTypeAlias {\n  override def aliasName = RecordAlias("ParentBundle")\n  val child = new Child\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'emitFIRRTL(new Module {\n  val wire = Wire(new Parent)\n})\n// res11: String = """FIRRTL version 3.3.0\n// circuit _22_Anon :\n//   type ChildBundle = { x : UInt<8>}\n//   type ParentBundle = { child : ChildBundle}\n// \n//   module _22_Anon :\n//     input clock : Clock\n//     input reset : UInt<1>\n// \n//     wire wire : ParentBundle @[naming.md 276:18]\n// \n// """\n')),(0,i.kt)("h3",{id:"why-do-i-keep-seeing-_stripped-suffixing-everywhere-in-my-firrtl-i-didnt-specify-that-in-my-aliasname"},"Why do I keep seeing _stripped suffixing everywhere in my FIRRTL? I didn't specify that in my ",(0,i.kt)("inlineCode",{parentName:"h3"},"aliasName"),"."),(0,i.kt)("p",null,"You're using an ",(0,i.kt)("inlineCode",{parentName:"p"},"Input(...)")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Output(...)")," in conjunction with an aliased ",(0,i.kt)("inlineCode",{parentName:"p"},"Record")," that contains a ",(0,i.kt)("inlineCode",{parentName:"p"},"Flipped(...)"),". These flipped values are stripped by ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Output")," which fundamentally changes the type of the parent ",(0,i.kt)("inlineCode",{parentName:"p"},"Record"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'class StrippedBundle extends Bundle with HasTypeAlias {\n  override def aliasName = RecordAlias("StrippedBundle")\n  val flipped = Flipped(UInt(8.W))\n  val normal = UInt(8.W)\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'emitFIRRTL(new Module {\n  val in = IO(Input(new StrippedBundle))\n})\n// res12: String = """FIRRTL version 3.3.0\n// circuit _26_Anon :\n//   type StrippedBundle_stripped = { flipped : UInt<8>, normal : UInt<8>}\n// \n//   module _26_Anon :\n//     input clock : Clock\n//     input reset : UInt<1>\n//     input in : StrippedBundle_stripped @[naming.md 294:14]\n// \n//     skip\n// \n// """\n')),(0,i.kt)("p",null,"Note how the bundle type doesn't contain a ",(0,i.kt)("inlineCode",{parentName:"p"},"flip flipped : UInt<8>")," field, and the alias gains a ",(0,i.kt)("inlineCode",{parentName:"p"},'"_stripped"')," suffix! This ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundle")," type is no longer the same as the one we wrote in Chisel, so we have to distinguish it as such."),(0,i.kt)("p",null,"By default, the suffix appended to ",(0,i.kt)("inlineCode",{parentName:"p"},"Record")," names is ",(0,i.kt)("inlineCode",{parentName:"p"},'"_stripped"'),". This can be defined by users with an additional string argument passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"RecordAlias(alias, strippedSuffix)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'class CustomStrippedBundle extends Bundle with HasTypeAlias {\n  override def aliasName = RecordAlias("StrippedBundle", "Foo")\n  val flipped = Flipped(UInt(8.W))\n  val normal = UInt(8.W)\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'emitFIRRTL(new Module {\n  val in = IO(Input(new CustomStrippedBundle))\n})\n// res13: String = """FIRRTL version 3.3.0\n// circuit _30_Anon :\n//   type StrippedBundleFoo = { flipped : UInt<8>, normal : UInt<8>}\n// \n//   module _30_Anon :\n//     input clock : Clock\n//     input reset : UInt<1>\n//     input in : StrippedBundleFoo @[naming.md 312:14]\n// \n//     skip\n// \n// """\n')),(0,i.kt)("h3",{id:"i-want-to-add-some-hardware-or-assertions-but-each-time-i-do-all-the-signal-names-get-bumped"},"I want to add some hardware or assertions, but each time I do all the signal names get bumped!"),(0,i.kt)("p",null,'This is the classic "ECO" problem, and we provide descriptions in ',(0,i.kt)("a",{parentName:"p",href:"../explanations/naming"},"explanation"),". In short,\nwe recommend wrapping all additional logic in a prefix scope, which enables a unique namespace. This should prevent\nname collisions, which are what triggers all those annoying signal name bumps!"),(0,i.kt)("h3",{id:"i-want-to-force-a-signal-or-instance-name-to-something-how-do-i-do-that"},"I want to force a signal (or instance) name to something, how do I do that?"),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},".suggestName")," method, which is on all classes which subtype ",(0,i.kt)("inlineCode",{parentName:"p"},"Data"),"."),(0,i.kt)("h3",{id:"how-can-i-omit-the-prefix-in-certain-parts-of-the-code"},"How can I omit the prefix in certain parts of the code?"),(0,i.kt)("p",null,"You can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"noPrefix { ... }")," to strip the prefix from all signals generated in that scope."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3.experimental.noPrefix\n\nclass ExampleNoPrefix extends Module {\n  val in = IO(Input(UInt(2.W)))\n  val out = IO(Output(UInt()))\n\n  val add = noPrefix {\n    // foo will not get a prefix\n    val foo = RegNext(in + 1.U)\n    foo + in\n  }\n\n  out := add\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule ExampleNoPrefix(\n  input        clock,\n               reset,\n  input  [1:0] in,\n  output [1:0] out\n);\n\n  reg [1:0] foo;\n  always @(posedge clock)\n    foo <= in + 2'h1;\n  assign out = foo + in;\nendmodule\n\n")),(0,i.kt)("h3",{id:"i-am-still-not-getting-the-name-i-want-for-example-inlining-an-instance-changes-my-name"},"I am still not getting the name I want. For example, inlining an instance changes my name!"),(0,i.kt)("p",null,"In cases where a FIRRTL transform renames a signal/instance, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"forcename")," API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import chisel3.util.experimental.{forceName, InlineInstance}\n\nclass WrapperExample extends Module {\n  val in = IO(Input(UInt(3.W)))\n  val out = IO(Output(UInt(3.W)))\n  val inst = Module(new Wrapper)\n  inst.in := in\n  out := inst.out\n}\nclass Wrapper extends Module with InlineInstance {\n  val in = IO(Input(UInt(3.W)))\n  val out = IO(Output(UInt(3.W)))\n  val inst = Module(new MyLeaf)\n  forceName(inst, "inst")\n  inst.in := in\n  out := inst.out\n}\nclass MyLeaf extends Module {\n  val in = IO(Input(UInt(3.W)))\n  val out = IO(Output(UInt(3.W)))\n  out := in\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule MyLeaf(\n  input  [2:0] in,\n  output [2:0] out\n);\n\n  assign out = in;\nendmodule\n\nmodule WrapperExample(\n  input        clock,\n               reset,\n  input  [2:0] in,\n  output [2:0] out\n);\n\n  MyLeaf inst (\n    .in  (in),\n    .out (out)\n  );\nendmodule\n\n")),(0,i.kt)("p",null,"This can be used to rename instances and non-aggregate typed signals."))}m.isMDXComponent=!0}}]);