"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[7408],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=a.createContext({}),s=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(u.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,l=e.originalType,u=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=s(t),c=o,g=d["".concat(u,".").concat(c)]||d[c]||m[c]||l;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var l=t.length,i=new Array(l);i[0]=c;var r={};for(var u in n)hasOwnProperty.call(n,u)&&(r[u]=n[u]);r.originalType=e,r[d]="string"==typeof e?e:o,i[1]=r;for(var s=2;s<l;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},4654:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>s});var a=t(7462),o=(t(7294),t(3905));const l={layout:"docs",title:"Naming",section:"chisel3"},i="Naming",r={unversionedId:"explanations/naming",id:"explanations/naming",title:"Naming",description:"Historically, Chisel has had trouble reliably capturing the names of signals. The reasons for this are due to (1)",source:"@site/docs/explanations/naming.md",sourceDirName:"explanations",slug:"/explanations/naming",permalink:"/chisel/docs/explanations/naming",draft:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/naming.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Naming",section:"chisel3"},sidebar:"tutorialSidebar",previous:{title:"Muxes and Input Selection",permalink:"/chisel/docs/explanations/muxes-and-input-selection"},next:{title:"Operators",permalink:"/chisel/docs/explanations/operators"}},u={},s=[{value:"Compiler Plugin",id:"compiler-plugin",level:3},{value:"Prefixing",id:"prefixing",level:3},{value:"Suggest a Signal&#39;s Name (or the instance name of a Module)",id:"suggest-a-signals-name-or-the-instance-name-of-a-module",level:3},{value:"Behavior for &quot;Unnamed signals&quot; (aka &quot;Temporaries&quot;)",id:"behavior-for-unnamed-signals-aka-temporaries",level:3},{value:"Set a Module Name",id:"set-a-module-name",level:3}],p={toc:s},d="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"naming"},"Naming"),(0,o.kt)("p",null,"Historically, Chisel has had trouble reliably capturing the names of signals. The reasons for this are due to (1)\nprimarily relying on reflection to find names, (2) using ",(0,o.kt)("inlineCode",{parentName:"p"},"@chiselName")," macro which had unreliable behavior."),(0,o.kt)("p",null,"Chisel 3.4 introduced a custom Scala compiler plugin which enables reliabe and automatic capturing of signal names, when\nthey are declared. In addition, this release includes prolific use of a new prefixing API which enables more stable\nnaming of signals programmatically generated from function calls."),(0,o.kt)("p",null,"This document explains how naming now works in Chisel for signal and module names. For cookbook examples on how to fix\nsystemic name-stability issues, please refer to the naming ",(0,o.kt)("a",{parentName:"p",href:"../cookbooks/naming"},"cookbook"),"."),(0,o.kt)("h3",{id:"compiler-plugin"},"Compiler Plugin"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"// Imports used by the following examples\nimport chisel3._\nimport chisel3.experimental.{prefix, noPrefix}\n")),(0,o.kt)("p",null,"Chisel users must also include the compiler plugin in their build settings.\nIn SBT this is something like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'// For chisel versions 5.0.0+\naddCompilerPlugin("org.chipsalliance" % "chisel-plugin" % "5.0.0" cross CrossVersion.full)\n// For older chisel3 versions, eg. 3.6.0\naddCompilerPlugin("edu.berkeley.cs" % "chisel3-plugin" % "3.6.0" cross CrossVersion.full)\n')),(0,o.kt)("p",null,"This plugin will run after the 'typer' phase of the Scala compiler. It looks for any user code which is of the form\n",(0,o.kt)("inlineCode",{parentName:"p"},"val x = y"),", where ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"chisel3.Data"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"chisel3.MemBase"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"chisel3.experimental.BaseModule"),". For each\nline which fits this criteria, it rewrites that line. In the following examples, the commented line is the what the\nline above is rewritten to."),(0,o.kt)("p",null,"If the line is within a bundle declaration or is a module instantiation, it is rewritten to replace the right hand\nside with a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"autoNameRecursively"),", which names the signal/module."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class MyBundle extends Bundle {\n  val foo = Input(UInt(3.W))\n  // val foo = autoNameRecursively("foo")(Input(UInt(3.W)))\n}\nclass Example1 extends Module {\n  val io = IO(new MyBundle())\n  // val io = autoNameRecursively("io")(IO(new MyBundle()))\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule Example1(\n  input       clock,\n              reset,\n  input [2:0] io_foo\n);\n\nendmodule\n\n")),(0,o.kt)("p",null,"Otherwise, it is rewritten to also include the name as a prefix to any signals generated while executing the right-hand-\nside of the val declaration:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class Example2 extends Module {\n  val in = IO(Input(UInt(2.W)))\n  // val in = autoNameRecursively("in")(prefix("in")(IO(Input(UInt(2.W)))))\n\n  val out1 = IO(Output(UInt(4.W)))\n  // val out1 = autoNameRecursively("out1")(prefix("out1")(IO(Output(UInt(4.W)))))\n  val out2 = IO(Output(UInt(4.W)))\n  // val out2 = autoNameRecursively("out2")(prefix("out2")(IO(Output(UInt(4.W)))))\n  val out3 = IO(Output(UInt(4.W)))\n  // val out3 = autoNameRecursively("out3")(prefix("out3")(IO(Output(UInt(4.W)))))\n\n  def func() = {\n    val squared = in * in\n    // val squared = autoNameRecursively("squared")(prefix("squared")(in * in))\n    out1 := squared\n    val delay = RegNext(squared)\n    // val delay = autoNameRecursively("delay")(prefix("delay")(RegNext(squared)))\n    delay\n  }\n\n  val masked = 0xa.U & func()\n  // val masked = autoNameRecursively("masked")(prefix("masked")(0xa.U & func()))\n  // Note that values created inside of `func()`` are prefixed with `masked`\n\n  out2 := masked + 1.U\n  out3 := masked - 1.U\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule Example2(\n  input        clock,\n               reset,\n  input  [1:0] in,\n  output [3:0] out1,\n               out2,\n               out3\n);\n\n  wire [3:0] _GEN = {2'h0, in};\n  wire [3:0] masked_squared = _GEN * _GEN;\n  reg  [3:0] masked_delay;\n  wire [3:0] masked = masked_delay & 4'hA;\n  always @(posedge clock)\n    masked_delay <= masked_squared;\n  assign out1 = masked_squared;\n  assign out2 = masked + 4'h1;\n  assign out3 = masked - 4'h1;\nendmodule\n\n")),(0,o.kt)("p",null,"Prefixing can also be derived from the name of signals on the left-hand side of a connection.\nWhile this is not implemented via the compiler plugin, the behavior should feel similar:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class ConnectPrefixing extends Module {\n  val in = IO(Input(UInt(2.W)))\n  // val in = autoNameRecursively("in")(prefix("in")(IO(Input(UInt(2.W)))))\n\n  val out1 = IO(Output(UInt(4.W)))\n  // val out1 = autoNameRecursively("out1")(prefix("out1")(IO(Output(UInt(4.W)))))\n  val out2 = IO(Output(UInt(4.W)))\n  // val out2 = autoNameRecursively("out2")(prefix("out2")(IO(Output(UInt(4.W)))))\n\n  out1 := { // technically this is not wrapped in autoNameRecursively nor prefix\n    // But the Chisel runtime will still use the name of `out1` as a prefix\n    val squared = in * in\n    out2 := squared\n    val delayed = RegNext(squared)\n    // val delayed = autoNameRecursively("delayed")(prefix("delayed")(RegNext(squared)))\n    delayed + 1.U\n  }\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule ConnectPrefixing(\n  input        clock,\n               reset,\n  input  [1:0] in,\n  output [3:0] out1,\n               out2\n);\n\n  wire [3:0] _GEN = {2'h0, in};\n  wire [3:0] out1_squared = _GEN * _GEN;\n  reg  [3:0] out1_delayed;\n  always @(posedge clock)\n    out1_delayed <= out1_squared;\n  assign out1 = out1_delayed + 4'h1;\n  assign out2 = out1_squared;\nendmodule\n\n")),(0,o.kt)("p",null,"Note that the naming also works if the hardware type is nested in an ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," or a subtype of ",(0,o.kt)("inlineCode",{parentName:"p"},"Iterable"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class Example3 extends Module {\n  val in = IO(Input(UInt(2.W)))\n  // val in = autoNameRecursively("in")(prefix("in")(IO(Input(UInt(2.W)))))\n\n  val out = IO(Output(UInt()))\n  // val out = autoNameRecursively("out")(prefix("out")(IO(Output(UInt()))))\n\n  def func() = {\n    val delay = RegNext(in)\n    delay + 1.U\n  }\n\n  val opt = Some(func())\n  // Note that the register in func() is prefixed with `opt`:\n  // val opt = autoNameRecursively("opt")(prefix("opt")(Some(func()))\n\n  out := opt.get + 1.U\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule Example3(\n  input        clock,\n               reset,\n  input  [1:0] in,\n  output [1:0] out\n);\n\n  reg [1:0] opt_delay;\n  always @(posedge clock)\n    opt_delay <= in;\n  assign out = opt_delay - 2'h2;\nendmodule\n\n")),(0,o.kt)("p",null,"There is also a slight variant (",(0,o.kt)("inlineCode",{parentName:"p"},"autoNameRecursivelyProduct"),") for naming hardware with names provided by an unapply:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class UnapplyExample extends Module {\n  def mkIO() = (IO(Input(UInt(2.W))), IO(Output(UInt())))\n  val (in, out) = mkIO()\n  // val (in, out) = autoNameRecursivelyProduct(List(Some("in"), Some("out")))(mkIO())\n\n  out := in\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule UnapplyExample(\n  input        clock,\n               reset,\n  input  [1:0] in,\n  output [1:0] out\n);\n\n  assign out = in;\nendmodule\n\n")),(0,o.kt)("p",null,"Note that the compiler plugin will not insert a prefix in these cases because it is ambiguous what the prefix should be.\nUsers who desire a prefix are encouraged to provide one as ",(0,o.kt)("a",{parentName:"p",href:"#prefixing"},"described below"),"."),(0,o.kt)("h3",{id:"prefixing"},"Prefixing"),(0,o.kt)("p",null,"As shown above, the compiler plugin automatically attempts to prefix some of your signals for you.\nHowever, you as a user can also add your own prefixes by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"prefix(...)"),":"),(0,o.kt)("p",null,"Also note that the prefixes append to each other (including the prefix generated by the compiler plugin):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class Example6 extends Module {\n  val in = IO(Input(UInt(2.W)))\n  val out = IO(Output(UInt()))\n\n  val add = prefix("foo") {\n    val sum = RegNext(in + 1.U)\n    sum + 1.U\n  }\n\n  out := add\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule Example6(\n  input        clock,\n               reset,\n  input  [1:0] in,\n  output [1:0] out\n);\n\n  reg [1:0] add_foo_sum;\n  always @(posedge clock)\n    add_foo_sum <= in + 2'h1;\n  assign out = add_foo_sum + 2'h1;\nendmodule\n\n")),(0,o.kt)("p",null,"Sometimes you may want to disable the prefixing. This might occur if you are writing a library function and\ndon't want the prefixing behavior. In this case, you can call ",(0,o.kt)("inlineCode",{parentName:"p"},"noPrefix"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"class Example7 extends Module {\n  val in = IO(Input(UInt(2.W)))\n  val out = IO(Output(UInt()))\n\n  val add = noPrefix { \n    val sum = RegNext(in + 1.U)\n    sum + 1.U\n  }\n\n  out := add\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule Example7(\n  input        clock,\n               reset,\n  input  [1:0] in,\n  output [1:0] out\n);\n\n  reg [1:0] sum;\n  always @(posedge clock)\n    sum <= in + 2'h1;\n  assign out = sum + 2'h1;\nendmodule\n\n")),(0,o.kt)("h3",{id:"suggest-a-signals-name-or-the-instance-name-of-a-module"},"Suggest a Signal's Name (or the instance name of a Module)"),(0,o.kt)("p",null,"If you want to specify the name of a signal, you can always use the ",(0,o.kt)("inlineCode",{parentName:"p"},".suggestName")," API. Please note that the suggested\nname will still be prefixed (including by the plugin). You can always use the ",(0,o.kt)("inlineCode",{parentName:"p"},"noPrefix")," object to strip this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class Example8 extends Module {\n  val in = IO(Input(UInt(2.W)))\n  val out = IO(Output(UInt()))\n\n  val add = {\n    val sum = RegNext(in + 1.U).suggestName("foo")\n    sum + 1.U\n  }\n\n  out := add\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule Example8(\n  input        clock,\n               reset,\n  input  [1:0] in,\n  output [1:0] out\n);\n\n  reg [1:0] add_foo;\n  always @(posedge clock)\n    add_foo <= in + 2'h1;\n  assign out = add_foo + 2'h1;\nendmodule\n\n")),(0,o.kt)("p",null,"Note that using ",(0,o.kt)("inlineCode",{parentName:"p"},".suggestName")," does ",(0,o.kt)("strong",{parentName:"p"},"not")," affect prefixes derived from val names;\nhowever, it ",(0,o.kt)("em",{parentName:"p"},"can")," affect prefixes derived from connections (eg. ",(0,o.kt)("inlineCode",{parentName:"p"},":="),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class ConnectionPrefixExample extends Module {\n  val in0 = IO(Input(UInt(2.W)))\n  val in1 = IO(Input(UInt(2.W)))\n\n  val out0 = {\n    val port = IO(Output(UInt()))\n    // Even though this suggestName is before mul, the prefix used in this scope\n    // is derived from `val out0`, so this does not affect the name of mul\n    port.suggestName("foo")\n    // out0_mul\n    val mul = RegNext(in0 * in1)\n    port := mul + 1.U\n    port\n  }\n\n  val out1 = IO(Output(UInt()))\n  val out2 = IO(Output(UInt()))\n\n  out1 := {\n    // out1_sum\n    val sum = RegNext(in0 + in1)\n    sum + 1.U\n  }\n  // Comes after so does *not* affect prefix above\n  out1.suggestName("bar")\n\n  // Comes before so *does* affect prefix below\n  out2.suggestName("fizz")\n  out2 := {\n    // fizz_diff\n    val diff = RegNext(in0 - in1)\n    diff + 1.U\n  }\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule ConnectionPrefixExample(\n  input        clock,\n               reset,\n  input  [1:0] in0,\n               in1,\n  output [3:0] foo,\n  output [1:0] bar,\n               fizz\n);\n\n  reg [3:0] out0_mul;\n  reg [1:0] out1_sum;\n  reg [1:0] fizz_diff;\n  always @(posedge clock) begin\n    out0_mul <= {2'h0, in0} * {2'h0, in1};\n    out1_sum <= in0 + in1;\n    fizz_diff <= in0 - in1;\n  end // always @(posedge)\n  assign foo = out0_mul + 4'h1;\n  assign bar = out1_sum + 2'h1;\n  assign fizz = fizz_diff + 2'h1;\nendmodule\n\n")),(0,o.kt)("p",null,"As this example illustrates, this behavior is slightly inconsistent so is subject to change in a future version of Chisel."),(0,o.kt)("h3",{id:"behavior-for-unnamed-signals-aka-temporaries"},'Behavior for "Unnamed signals" (aka "Temporaries")'),(0,o.kt)("p",null,"If you want to signify that the name of a signal does not matter, you can prefix the name of your val with ",(0,o.kt)("inlineCode",{parentName:"p"},"_"),".\nChisel will preserve the convention of leading ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," signifying an unnamed signal across prefixes.\nFor example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class TemporaryExample extends Module {\n  val in0 = IO(Input(UInt(2.W)))\n  val in1 = IO(Input(UInt(2.W)))\n\n  val out = {\n    // We need 2 ports so firtool will maintain the common subexpression\n    val port0 = IO(Output(UInt()))\n    // out_port1\n    val port1 = IO(Output(UInt()))\n    val _sum = in0 + in1\n    port0 := _sum + 1.U\n    port1 := _sum - 1.U\n    // port0 is returned so will get the name "out"\n    port0\n  }\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule TemporaryExample(\n  input        clock,\n               reset,\n  input  [1:0] in0,\n               in1,\n  output [1:0] out,\n               out_port1\n);\n\n  wire [1:0] _out_sum_T = in0 + in1;\n  assign out = _out_sum_T + 2'h1;\n  assign out_port1 = _out_sum_T - 2'h1;\nendmodule\n\n")),(0,o.kt)("p",null,"If an unnamed signal is itself used to generate a prefix, the leading ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," will be ignored to avoid double ",(0,o.kt)("inlineCode",{parentName:"p"},"__")," in the names of further nested signals."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"class TemporaryPrefixExample extends Module {\n  val in0 = IO(Input(UInt(2.W)))\n  val in1 = IO(Input(UInt(2.W)))\n  val out0 = IO(Output(UInt()))\n  val out1 = IO(Output(UInt()))\n\n  val _sum = {\n    val x = in0 + in1\n    out0 := x\n    x + 1.U\n  }\n  out1 := _sum & 0x2.U\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule TemporaryPrefixExample(\n  input        clock,\n               reset,\n  input  [1:0] in0,\n               in1,\n  output [1:0] out0,\n               out1\n);\n\n  wire [1:0] _sum_x_T = in0 + in1;\n  assign out0 = _sum_x_T;\n  assign out1 = _sum_x_T + 2'h1 & 2'h2;\nendmodule\n\n")),(0,o.kt)("h3",{id:"set-a-module-name"},"Set a Module Name"),(0,o.kt)("p",null,"If you want to specify the module's name (not the instance name of a module), you can always override the ",(0,o.kt)("inlineCode",{parentName:"p"},"desiredName"),"\nvalue. Note that you can parameterize the name by the module's parameters. This is an excellent way to make your module\nnames more stable and is highly recommended to do."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'class Example9(width: Int) extends Module {\n  override val desiredName = s"EXAMPLE9WITHWIDTH$width"\n  val in = IO(Input(UInt(width.W)))\n  val out = IO(Output(UInt()))\n\n  val add = (in + (in + in).suggestName("foo"))\n\n  out := add\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule EXAMPLE9WITHWIDTH8(\n  input        clock,\n               reset,\n  input  [7:0] in,\n  output [7:0] out\n);\n\n  assign out = in + {in[6:0], 1'h0};\nendmodule\n\n// Generated by CIRCT firtool-1.56.0\nmodule EXAMPLE9WITHWIDTH1(\n  input  clock,\n         reset,\n         in,\n  output out\n);\n\n  assign out = in;\nendmodule\n\n")))}m.isMDXComponent=!0}}]);