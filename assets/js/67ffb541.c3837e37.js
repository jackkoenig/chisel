"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[9560],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>w});var n=t(7294);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function r(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=n.createContext({}),p=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):o(o({},a),e)),t},d=function(e){var a=p(e.components);return n.createElement(s.Provider,{value:a},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=p(t),m=i,w=u["".concat(s,".").concat(m)]||u[m]||c[m]||l;return t?n.createElement(w,o(o({ref:a},d),{},{components:t})):n.createElement(w,o({ref:a},d))}));function w(e,a){var t=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var l=t.length,o=new Array(l);o[0]=m;var r={};for(var s in a)hasOwnProperty.call(a,s)&&(r[s]=a[s]);r.originalType=e,r[u]="string"==typeof e?e:i,o[1]=r;for(var p=2;p<l;p++)o[p]=t[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8421:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>p});var n=t(7462),i=(t(7294),t(3905));const l={layout:"docs",title:"DataView",section:"chisel3"},o="DataView",r={unversionedId:"explanations/dataview",id:"explanations/dataview",title:"DataView",description:"New in Chisel 3.5",source:"@site/docs/explanations/dataview.md",sourceDirName:"explanations",slug:"/explanations/dataview",permalink:"/chisel/docs/explanations/dataview",draft:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/explanations/dataview.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"DataView",section:"chisel3"},sidebar:"tutorialSidebar",previous:{title:"Chisel Data Types",permalink:"/chisel/docs/explanations/data-types"},next:{title:"Decoders",permalink:"/chisel/docs/explanations/decoder"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"A Motivating Example (AXI4)",id:"a-motivating-example-axi4",level:2},{value:"Other Use Cases",id:"other-use-cases",level:2},{value:"Tuples",id:"tuples",level:3},{value:"Totality and PartialDataView",id:"totality-and-partialdataview",level:2},{value:"Advanced Details",id:"advanced-details",level:2},{value:"Type Classes",id:"type-classes",level:3},{value:"Implicit Resolution",id:"implicit-resolution",level:3},{value:"Implicit Resolution Example",id:"implicit-resolution-example",level:4},{value:"DataProduct",id:"dataproduct",level:3}],d={toc:p},u="wrapper";function c(e){let{components:a,...t}=e;return(0,i.kt)(u,(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dataview"},"DataView"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"New in Chisel 3.5")),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,'DataView is a mechanism for "viewing" Scala objects as a subtype of ',(0,i.kt)("inlineCode",{parentName:"p"},"chisel3.Data"),".\nOften, this is useful for viewing one subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"chisel3.Data"),", as another.\nOne can think about a ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," as a mapping from a ",(0,i.kt)("em",{parentName:"p"},"Target")," type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," to a ",(0,i.kt)("em",{parentName:"p"},"View")," type ",(0,i.kt)("inlineCode",{parentName:"p"},"V"),".\nThis is similar to a cast (eg. ",(0,i.kt)("inlineCode",{parentName:"p"},".asTypeOf"),") with a few differences:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Views are ",(0,i.kt)("em",{parentName:"li"},"connectable"),"\u2014connections to the view will occur on the target"),(0,i.kt)("li",{parentName:"ol"},"Whereas casts are ",(0,i.kt)("em",{parentName:"li"},"structural")," (a reinterpretation of the underlying bits), a DataView is a customizable mapping"),(0,i.kt)("li",{parentName:"ol"},"Views can be ",(0,i.kt)("em",{parentName:"li"},"partial"),"\u2014not every field in the target must be included in the mapping")),(0,i.kt)("h2",{id:"a-motivating-example-axi4"},"A Motivating Example (AXI4)"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Advanced_eXtensible_Interface"},"AXI4")," is a common interface in digital\ndesign.\nA typical Verilog peripheral using AXI4 will define a write channel as something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module my_module(\n  // Write Channel\n  input        AXI_AWVALID,\n  output       AXI_AWREADY,\n  input [3:0]  AXI_AWID,\n  input [19:0] AXI_AWADDR,\n  input [1:0]  AXI_AWLEN,\n  input [1:0]  AXI_AWSIZE,\n  // ...\n);\n")),(0,i.kt)("p",null,"This would correspond to the following Chisel Bundle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class VerilogAXIBundle(val addrWidth: Int) extends Bundle {\n  val AWVALID = Output(Bool())\n  val AWREADY = Input(Bool())\n  val AWID = Output(UInt(4.W))\n  val AWADDR = Output(UInt(addrWidth.W))\n  val AWLEN = Output(UInt(2.W))\n  val AWSIZE = Output(UInt(2.W))\n  // The rest of AW and other AXI channels here\n}\n\n// Instantiated as\nclass my_module extends RawModule {\n  val AXI = IO(new VerilogAXIBundle(20))\n}\n")),(0,i.kt)("p",null,"Expressing something that matches a standard Verilog interface is important when instantiating Verilog\nmodules in a Chisel design as ",(0,i.kt)("inlineCode",{parentName:"p"},"BlackBoxes"),".\nGenerally though, Chisel developers prefer to use composition via utilities like ",(0,i.kt)("inlineCode",{parentName:"p"},"Decoupled")," rather\nthan a flat handling of ",(0,i.kt)("inlineCode",{parentName:"p"},"ready")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"valid"),' as in the above.\nA more "Chisel-y" implementation of this interface might look like:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Note that both the AW and AR channels look similar and could use the same Bundle definition\nclass AXIAddressChannel(val addrWidth: Int) extends Bundle {\n  val id = UInt(4.W)\n  val addr = UInt(addrWidth.W)\n  val len = UInt(2.W)\n  val size = UInt(2.W)\n  // ...\n}\nimport chisel3.util.Decoupled\n// We can compose the various AXI channels together\nclass AXIBundle(val addrWidth: Int) extends Bundle {\n  val aw = Decoupled(new AXIAddressChannel(addrWidth))\n  // val ar = new AXIAddressChannel\n  // ... Other channels here ...\n}\n// Instantiated as\nclass MyModule extends RawModule {\n  val axi = IO(new AXIBundle(20))\n}\n")),(0,i.kt)("p",null,"Of course, this would result in very different looking Verilog:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule MyModule(    // <stdin>:3:3\n  input         axi_aw_ready,   // dataview.md:53:15\n  output        axi_aw_valid,   // dataview.md:53:15\n  output [3:0]  axi_aw_bits_id, // dataview.md:53:15\n  output [19:0] axi_aw_bits_addr,   // dataview.md:53:15\n  output [1:0]  axi_aw_bits_len,    // dataview.md:53:15\n                axi_aw_bits_size    // dataview.md:53:15\n);\n\n  assign axi_aw_valid = 1'h0;   // <stdin>:3:3, dataview.md:62:7\n  assign axi_aw_bits_id = 4'h0; // <stdin>:3:3, dataview.md:62:7\n  assign axi_aw_bits_addr = 20'h0;  // <stdin>:3:3, dataview.md:62:7\n  assign axi_aw_bits_len = 2'h0;    // <stdin>:3:3, dataview.md:62:7\n  assign axi_aw_bits_size = 2'h0;   // <stdin>:3:3, dataview.md:62:7\nendmodule\n\n")),(0,i.kt)("p",null,"So how can we use our more structured types while maintaining expected Verilog interfaces?\nMeet DataView:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3.experimental.dataview._\n\n// We recommend putting DataViews in a companion object of one of the involved types\nobject AXIBundle {\n  // Don't be afraid of the use of implicits, we will discuss this pattern in more detail later\n  implicit val axiView = DataView[VerilogAXIBundle, AXIBundle](\n    // The first argument is a function constructing an object of View type (AXIBundle)\n    // from an object of the Target type (VerilogAXIBundle)\n    vab => new AXIBundle(vab.addrWidth),\n    // The remaining arguments are a mapping of the corresponding fields of the two types\n    _.AWVALID -> _.aw.valid,\n    _.AWREADY -> _.aw.ready,\n    _.AWID -> _.aw.bits.id,\n    _.AWADDR -> _.aw.bits.addr,\n    _.AWLEN -> _.aw.bits.len,\n    _.AWSIZE -> _.aw.bits.size,\n    // ...\n  )\n}\n")),(0,i.kt)("p",null,"This ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," is a mapping between our flat, Verilog-style AXI Bundle to our more compositional,\nChisel-style AXI Bundle.\nIt allows us to define our ports to match the expected Verilog interface, while manipulating it as if\nit were the more structured type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class AXIStub extends RawModule {\n  val AXI = IO(new VerilogAXIBundle(20))\n  val view = AXI.viewAs[AXIBundle]\n\n  // We can now manipulate `AXI` via `view`\n  view.aw.bits := 0.U.asTypeOf(new AXIAddressChannel(20)) // zero everything out by default\n  view.aw.valid := true.B\n  when (view.aw.ready) {\n    view.aw.bits.id := 5.U\n    view.aw.bits.addr := 1234.U\n    // We can still manipulate AXI as well\n    AXI.AWLEN := 1.U\n  }\n}\n")),(0,i.kt)("p",null,"This will generate Verilog that matches the standard naming convention:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule AXIStub( // <stdin>:3:3\n  input         AXI_AWREADY,    // dataview.md:94:15\n  output        AXI_AWVALID,    // dataview.md:94:15\n  output [3:0]  AXI_AWID,   // dataview.md:94:15\n  output [19:0] AXI_AWADDR, // dataview.md:94:15\n  output [1:0]  AXI_AWLEN,  // dataview.md:94:15\n                AXI_AWSIZE  // dataview.md:94:15\n);\n\n  assign AXI_AWVALID = 1'h1;    // <stdin>:3:3, dataview.md:99:17\n  assign AXI_AWID = AXI_AWREADY ? 4'h5 : 4'h0;  // <stdin>:3:3, dataview.md:98:{16,31}, :100:24, :101:21\n  assign AXI_AWADDR = AXI_AWREADY ? 20'h4D2 : 20'h0;    // <stdin>:3:3, dataview.md:98:{16,31}, :100:24, :102:23\n  assign AXI_AWLEN = {1'h0, AXI_AWREADY};   // <stdin>:3:3, dataview.md:98:16, :100:24, :104:15\n  assign AXI_AWSIZE = 2'h0; // <stdin>:3:3, dataview.md:98:31\nendmodule\n\n")),(0,i.kt)("p",null,"Note that if both the ",(0,i.kt)("em",{parentName:"p"},"Target")," and the ",(0,i.kt)("em",{parentName:"p"},"View")," types are subtypes of ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," (as they are in this example),\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," is ",(0,i.kt)("em",{parentName:"p"},"invertible"),".\nThis means that we can easily create a ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView[AXIBundle, VerilogAXIBundle]")," from our existing\n",(0,i.kt)("inlineCode",{parentName:"p"},"DataView[VerilogAXIBundle, AXIBundle]"),", all we need to do is provide a function to construct\na ",(0,i.kt)("inlineCode",{parentName:"p"},"VerilogAXIBundle")," from an instance of an ",(0,i.kt)("inlineCode",{parentName:"p"},"AXIBundle"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Note that typically you should define these together (eg. inside object AXIBundle)\nimplicit val axiView2 = AXIBundle.axiView.invert(ab => new VerilogAXIBundle(ab.addrWidth))\n")),(0,i.kt)("p",null,"The following example shows this and illustrates another use case of ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),"\u2014connecting unrelated\ntypes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class ConnectionExample extends RawModule {\n  val in = IO(new AXIBundle(20))\n  val out = IO(Flipped(new VerilogAXIBundle(20)))\n  out.viewAs[AXIBundle] <> in\n}\n")),(0,i.kt)("p",null,"This results in the corresponding fields being connected in the emitted Verilog:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule ConnectionExample(   // <stdin>:3:3\n  input         in_aw_ready,    // dataview.md:125:14\n                out_AWVALID,    // dataview.md:126:15\n  input  [3:0]  out_AWID,   // dataview.md:126:15\n  input  [19:0] out_AWADDR, // dataview.md:126:15\n  input  [1:0]  out_AWLEN,  // dataview.md:126:15\n                out_AWSIZE, // dataview.md:126:15\n  output        in_aw_valid,    // dataview.md:125:14\n  output [3:0]  in_aw_bits_id,  // dataview.md:125:14\n  output [19:0] in_aw_bits_addr,    // dataview.md:125:14\n  output [1:0]  in_aw_bits_len, // dataview.md:125:14\n                in_aw_bits_size,    // dataview.md:125:14\n  output        out_AWREADY // dataview.md:126:15\n);\n\n  assign in_aw_valid = out_AWVALID; // <stdin>:3:3\n  assign in_aw_bits_id = out_AWID;  // <stdin>:3:3\n  assign in_aw_bits_addr = out_AWADDR;  // <stdin>:3:3\n  assign in_aw_bits_len = out_AWLEN;    // <stdin>:3:3\n  assign in_aw_bits_size = out_AWSIZE;  // <stdin>:3:3\n  assign out_AWREADY = in_aw_ready; // <stdin>:3:3\nendmodule\n\n")),(0,i.kt)("h2",{id:"other-use-cases"},"Other Use Cases"),(0,i.kt)("p",null,"While the ability to map between ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundle")," types as in the AXI4 example is pretty compelling,\nDataView has many other applications.\nImportantly, because the ",(0,i.kt)("em",{parentName:"p"},"Target")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," need not be a ",(0,i.kt)("inlineCode",{parentName:"p"},"Data"),", it provides a way to use\n",(0,i.kt)("inlineCode",{parentName:"p"},"non-Data")," objects with APIs that require ",(0,i.kt)("inlineCode",{parentName:"p"},"Data"),"."),(0,i.kt)("h3",{id:"tuples"},"Tuples"),(0,i.kt)("p",null,"Perhaps the most helpful use of ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," for a non-",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," type is viewing Scala tuples as ",(0,i.kt)("inlineCode",{parentName:"p"},"Bundles"),".\nFor example, in Chisel prior to the introduction of ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),", one might try to ",(0,i.kt)("inlineCode",{parentName:"p"},"Mux")," tuples and\nsee an error like the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class TupleExample extends RawModule {\n  val a, b, c, d = IO(Input(UInt(8.W)))\n  val cond = IO(Input(Bool()))\n  val x, y = IO(Output(UInt(8.W)))\n  (x, y) := Mux(cond, (a, b), (c, d))\n}\n// error: value := is not a member of (chisel3.UInt, chisel3.UInt)\n//   Expression does not convert to assignment because receiver is not assignable.\n//   (x, y) := Mux(cond, (a, b), (c, d))\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n// error: inferred type arguments [(chisel3.UInt, chisel3.UInt)] do not conform to macro method apply's type parameter bounds [T <: chisel3.Data]\n//   (x, y) := Mux(cond, (a, b), (c, d))\n//             ^^^\n// error: type mismatch;\n//  found   : (chisel3.UInt, chisel3.UInt)\n//  required: T\n//   (x, y) := Mux(cond, (a, b), (c, d))\n//                       ^^^^^^\n// error: type mismatch;\n//  found   : (chisel3.UInt, chisel3.UInt)\n//  required: T\n//   (x, y) := Mux(cond, (a, b), (c, d))\n//                               ^^^^^^\n")),(0,i.kt)("p",null,"The issue, is that Chisel primitives like ",(0,i.kt)("inlineCode",{parentName:"p"},"Mux")," and ",(0,i.kt)("inlineCode",{parentName:"p"},":=")," only operate on subtypes of ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," and\nTuples (as members of the Scala standard library), are not subclasses of ",(0,i.kt)("inlineCode",{parentName:"p"},"Data"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," provides a mechanism to ",(0,i.kt)("em",{parentName:"p"},"view")," a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tuple")," as if it were a ",(0,i.kt)("inlineCode",{parentName:"p"},"Data"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// We need a type to represent the Tuple\nclass HWTuple2[A <: Data, B <: Data](val _1: A, val _2: B) extends Bundle\n\n// Provide DataView between Tuple and HWTuple\nimplicit def view[A <: Data, B <: Data]: DataView[(A, B), HWTuple2[A, B]] =\n  DataView(tup => new HWTuple2(tup._1.cloneType, tup._2.cloneType),\n           _._1 -> _._1, _._2 -> _._2)\n")),(0,i.kt)("p",null,"Now, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},".viewAs")," to view Tuples as if they were subtypes of ",(0,i.kt)("inlineCode",{parentName:"p"},"Data"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class TupleVerboseExample extends RawModule {\n  val a, b, c, d = IO(Input(UInt(8.W)))\n  val cond = IO(Input(Bool()))\n  val x, y = IO(Output(UInt(8.W)))\n  (x, y).viewAs[HWTuple2[UInt, UInt]] := Mux(cond, (a, b).viewAs[HWTuple2[UInt, UInt]], (c, d).viewAs[HWTuple2[UInt, UInt]])\n}\n")),(0,i.kt)("p",null,"This is much more verbose than the original idea of just using the Tuples directly as if they were ",(0,i.kt)("inlineCode",{parentName:"p"},"Data"),".\nWe can make this better by providing an implicit conversion that views a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tuple")," as a ",(0,i.kt)("inlineCode",{parentName:"p"},"HWTuple2"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"implicit def tuple2hwtuple[A <: Data, B <: Data](tup: (A, B)): HWTuple2[A, B] =\n  tup.viewAs[HWTuple2[A, B]]\n")),(0,i.kt)("p",null,"Now, the original code just works!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class TupleExample extends RawModule {\n  val a, b, c, d = IO(Input(UInt(8.W)))\n  val cond = IO(Input(Bool()))\n  val x, y = IO(Output(UInt(8.W)))\n  (x, y) := Mux(cond, (a, b), (c, d))\n}\n")),(0,i.kt)("p",null,"Note that this example ignored ",(0,i.kt)("inlineCode",{parentName:"p"},"DataProduct")," which is another required piece (see ",(0,i.kt)("a",{parentName:"p",href:"#dataproduct"},"the documentation\nabout it below"),")."),(0,i.kt)("p",null,"All of this is available to users via a single import:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3.experimental.conversions._\n")),(0,i.kt)("h2",{id:"totality-and-partialdataview"},"Totality and PartialDataView"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," is ",(0,i.kt)("em",{parentName:"p"},"total")," if all fields of the ",(0,i.kt)("em",{parentName:"p"},"Target")," type and all fields of the ",(0,i.kt)("em",{parentName:"p"},"View")," type are\nincluded in the mapping.\nChisel will error if a field is accidentally left out from a ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),".\nFor example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class BundleA extends Bundle {\n  val foo = UInt(8.W)\n  val bar = UInt(8.W)\n}\nclass BundleB extends Bundle {\n  val fizz = UInt(8.W)\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// We forgot BundleA.foo in the mapping!\nimplicit val myView = DataView[BundleA, BundleB](_ => new BundleB, _.bar -> _.fizz)\nclass BadMapping extends Module {\n   val in = IO(Input(new BundleA))\n   val out = IO(Output(new BundleB))\n   out := in.viewAs[BundleB]\n}\n// We must run Chisel to see the error\ngetVerilogString(new BadMapping)\n// chisel3.experimental.dataview.package$InvalidViewException: Viewing BadMapping.in: IO[BundleA] as BundleB is non-Total!\n//   Target field '_.foo' is missing.\n//   DataView used is DataView(defined @[dataview.md 228:49]).\n//   If the view *should* be non-total, try a 'PartialDataView'.\n//  at ... ()\n//  at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1$$anonfun$60.apply(dataview.md:232)\n//  at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1$$anonfun$60.apply(dataview.md:232)\n//  at chisel3.Data.$anonfun$$colon$eq$1(Data.scala:696)\n//  at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)\n//  at chisel3.experimental.prefix$.apply(prefix.scala:33)\n//  at chisel3.Data.$colon$eq(Data.scala:696)\n//  at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1.<init>(dataview.md:232)\n//  at repl.MdocSession$MdocApp6$$anonfun$55$$anonfun$apply$67.apply(dataview.md:234)\n//  at repl.MdocSession$MdocApp6$$anonfun$55$$anonfun$apply$67.apply(dataview.md:234)\n//  at ... ()\n//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)\n")),(0,i.kt)("p",null,"As that error suggests, if we ",(0,i.kt)("em",{parentName:"p"},"want")," the view to be non-total, we can use a ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialDataView"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// A PartialDataView does not have to be total for the Target\nimplicit val myView = PartialDataView[BundleA, BundleB](_ => new BundleB, _.bar -> _.fizz)\n// myView: DataView[BundleA, BundleB] = PartialDataView(defined @[dataview.md 243:56])\nclass PartialDataViewModule extends Module {\n   val in = IO(Input(new BundleA))\n   val out = IO(Output(new BundleB))\n   out := in.viewAs[BundleB]\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule PartialDataViewModule(   // <stdin>:3:3\n  input        clock,   // <stdin>:4:11\n               reset,   // <stdin>:5:11\n  input  [7:0] in_foo,  // dataview.md:247:15\n               in_bar,  // dataview.md:247:15\n  output [7:0] out_fizz // dataview.md:248:16\n);\n\n  assign out_fizz = in_bar; // <stdin>:3:3\nendmodule\n\n")),(0,i.kt)("p",null,"While ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialDataViews")," need not be total for the ",(0,i.kt)("em",{parentName:"p"},"Target"),", both ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialDataViews")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DataViews"),"\nmust always be total for the ",(0,i.kt)("em",{parentName:"p"},"View"),".\nThis has the consequence that ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialDataViews")," are ",(0,i.kt)("strong",{parentName:"p"},"not")," invertible in the same way as ",(0,i.kt)("inlineCode",{parentName:"p"},"DataViews"),"."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"implicit val myView2 = myView.invert(_ => new BundleA)\nclass PartialDataViewModule2 extends Module {\n   val in = IO(Input(new BundleA))\n   val out = IO(Output(new BundleB))\n   // Using the inverted version of the mapping\n   out.viewAs[BundleA] := in\n}\n// We must run Chisel to see the error\ngetVerilogString(new PartialDataViewModule2)\n// chisel3.experimental.dataview.package$InvalidViewException: Cannot invert 'PartialDataView(defined @[dataview.md 243:56])' as it is non-total.\n//   Try providing a DataView[MdocApp6.this.BundleB, MdocApp6.this.BundleA].\n//   Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview.\n//  at chisel3.experimental.dataview.DataView$InvertibleDataView.invert(DataView.scala:136)\n//  at repl.MdocSession$MdocApp6$$anonfun$67.apply(dataview.md:263)\n//  at repl.MdocSession$MdocApp6$$anonfun$67.apply(dataview.md:262)\n")),(0,i.kt)("p",null,"As noted, the mapping must ",(0,i.kt)("strong",{parentName:"p"},"always")," be total for the ",(0,i.kt)("inlineCode",{parentName:"p"},"View"),"."),(0,i.kt)("h2",{id:"advanced-details"},"Advanced Details"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," takes advantage of features of Scala that may be new to many users of Chisel\u2014in particular\n",(0,i.kt)("a",{parentName:"p",href:"#type-classes"},"Type Classes"),"."),(0,i.kt)("h3",{id:"type-classes"},"Type Classes"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Type_class"},"Type classes"),' are powerful language feature for writing\npolymorphic code.\nThey are a common feature in "modern programming languages" like\nScala,\nSwift (see ',(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/Protocols.html"},"protocols"),"),\nand Rust (see ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch10-02-traits.html"},"traits"),").\nType classes may appear similar to inheritance in object-oriented programming but there are some\nimportant  differences:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You can provide a type class for a type you don't own (eg. one defined in a 3rd party library,\nthe Scala standard library, or Chisel itself)"),(0,i.kt)("li",{parentName:"ol"},"You can write a single type class for many types that do not have a sub-typing relationship"),(0,i.kt)("li",{parentName:"ol"},"You can provide multiple different type classes for the same type")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),", (1) is crucial because we want to be able to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"DataViews")," of built-in Scala\ntypes like tuples and ",(0,i.kt)("inlineCode",{parentName:"p"},"Seqs"),". Furthermore, ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," has two type parameters (the ",(0,i.kt)("em",{parentName:"p"},"Target")," and the\n",(0,i.kt)("em",{parentName:"p"},"View")," types) so inheritance does not really make sense\u2014which type would ",(0,i.kt)("inlineCode",{parentName:"p"},"extend")," ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),"?"),(0,i.kt)("p",null,"In Scala 2, type classes are not a built-in language feature, but rather are implemented using implicits.\nThere are great resources out there for interested readers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://scalac.io/blog/typeclasses-in-scala/"},"Basic Tutorial")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://stackoverflow.com/a/5598107/2483329"},"Fantastic Explanation on StackOverflow"))),(0,i.kt)("p",null,"Note that Scala 3 has added built-in syntax for type classes that does not apply to Chisel 3 which\ncurrently only supports Scala 2."),(0,i.kt)("h3",{id:"implicit-resolution"},"Implicit Resolution"),(0,i.kt)("p",null,"Given that ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," is implemented using implicits, it is important to understand implicit\nresolution.\nWhenever the compiler sees an implicit argument is required, it first looks in ",(0,i.kt)("em",{parentName:"p"},"current scope"),"\nbefore looking in the ",(0,i.kt)("em",{parentName:"p"},"implicit scope"),"."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Current scope",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Values defined in the current scope"),(0,i.kt)("li",{parentName:"ul"},"Explicit imports"),(0,i.kt)("li",{parentName:"ul"},"Wildcard imports"))),(0,i.kt)("li",{parentName:"ol"},"Implicit scope",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Companion object of a type"),(0,i.kt)("li",{parentName:"ul"},"Implicit scope of an argument's type"),(0,i.kt)("li",{parentName:"ul"},"Implicit scope of type parameters")))),(0,i.kt)("p",null,"If at either stage, multiple implicits are found, then the static overloading rule is used to resolve\nit.\nPut simply, if one implicit applies to a more-specific type than the other, the more-specific one\nwill be selected.\nIf multiple implicits apply within a given stage, then the compiler throws an ambiguous implicit\nresolution error."),(0,i.kt)("p",null,"This section draws heavily from ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/5598107/2483329"},"[1]")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/8694558/2483329"},"[2]"),".\nIn particular, see ","[1]"," for examples."),(0,i.kt)("h4",{id:"implicit-resolution-example"},"Implicit Resolution Example"),(0,i.kt)("p",null,"To help clarify a bit, let us consider how implicit resolution works for ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),".\nConsider the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"viewAs"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def viewAs[V <: Data](implicit dataView: DataView[T, V]): V\n")),(0,i.kt)("p",null,"Armed with the knowledge from the previous section, we know that whenever we call ",(0,i.kt)("inlineCode",{parentName:"p"},".viewAs"),", the\nScala compiler will first look for a ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView[T, V]")," in the current scope (defined in, or imported),\nthen it will look in the companion objects of ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"V"),".\nThis enables a fairly powerful pattern, namely that default or typical implementations of a ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),"\nshould be defined in the companion object for one of the two types.\nWe can think about ",(0,i.kt)("inlineCode",{parentName:"p"},"DataViews"),' defined in this way as "low priority defaults".\nThey can then be overruled by a specific import if a given user ever wants different behavior.\nFor example:'),(0,i.kt)("p",null,"Given the following types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class Foo extends Bundle {\n  val a = UInt(8.W)\n  val b = UInt(8.W)\n}\nclass Bar extends Bundle {\n  val c = UInt(8.W)\n  val d = UInt(8.W)\n}\nobject Foo {\n  implicit val f2b = DataView[Foo, Bar](_ => new Bar, _.a -> _.c, _.b -> _.d)\n  implicit val b2f = f2b.invert(_ => new Foo)\n}\n")),(0,i.kt)("p",null,"This provides an implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView")," in the ",(0,i.kt)("em",{parentName:"p"},"implicit scope"),' as a "default" mapping between\n',(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," (and it doesn't even require an import!):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class FooToBar extends Module {\n  val foo = IO(Input(new Foo))\n  val bar = IO(Output(new Bar))\n  bar := foo.viewAs[Bar]\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule FooToBar(    // <stdin>:3:3\n  input        clock,   // <stdin>:4:11\n               reset,   // <stdin>:5:11\n  input  [7:0] foo_a,   // dataview.md:301:15\n               foo_b,   // dataview.md:301:15\n  output [7:0] bar_c,   // dataview.md:302:15\n               bar_d    // dataview.md:302:15\n);\n\n  assign bar_c = foo_a; // <stdin>:3:3\n  assign bar_d = foo_b; // <stdin>:3:3\nendmodule\n\n")),(0,i.kt)("p",null,"However, it's possible that some user of ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar"),' wants different behavior,\nperhaps they would prefer more of "swizzling" behavior rather than a direct mapping:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Swizzle {\n  implicit val swizzle = DataView[Foo, Bar](_ => new Bar, _.a -> _.d, _.b -> _.c)\n}\n// Current scope always wins over implicit scope\nimport Swizzle._\nclass FooToBarSwizzled extends Module {\n  val foo = IO(Input(new Foo))\n  val bar = IO(Output(new Bar))\n  bar := foo.viewAs[Bar]\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// Generated by CIRCT firtool-1.56.0\nmodule FooToBarSwizzled(    // <stdin>:3:3\n  input        clock,   // <stdin>:4:11\n               reset,   // <stdin>:5:11\n  input  [7:0] foo_a,   // dataview.md:325:15\n               foo_b,   // dataview.md:325:15\n  output [7:0] bar_c,   // dataview.md:326:15\n               bar_d    // dataview.md:326:15\n);\n\n  assign bar_c = foo_b; // <stdin>:3:3\n  assign bar_d = foo_a; // <stdin>:3:3\nendmodule\n\n")),(0,i.kt)("h3",{id:"dataproduct"},"DataProduct"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DataProduct")," is a type class used by ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),' to validate the correctness of a user-provided mapping.\nIn order for a type to be "viewable" (ie. the ',(0,i.kt)("inlineCode",{parentName:"p"},"Target")," type of a ",(0,i.kt)("inlineCode",{parentName:"p"},"DataView"),"), it must have an\nimplementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"DataProduct"),"."),(0,i.kt)("p",null,"For example, say we have some non-Bundle type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Loosely based on chisel3.util.Counter\nclass MyCounter(val width: Int) {\n  /** Indicates if the Counter is incrementing this cycle */\n  val active = WireDefault(false.B)\n  val value = RegInit(0.U(width.W))\n  def inc(): Unit = {\n    active := true.B\n    value := value + 1.U\n  }\n  def reset(): Unit = {\n    value := 0.U\n  }\n}\n")),(0,i.kt)("p",null,"Say we want to view ",(0,i.kt)("inlineCode",{parentName:"p"},"MyCounter")," as a ",(0,i.kt)("inlineCode",{parentName:"p"},"Valid[UInt]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import chisel3.util.Valid\nimplicit val counterView = DataView[MyCounter, Valid[UInt]](c => Valid(UInt(c.width.W)), _.value -> _.bits, _.active -> _.valid)\n// error: myView is already defined as value myView\n// implicit val myView = PartialDataView[BundleA, BundleB](_ => new BundleB, _.bar -> _.fizz)\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n// error: Could not find implicit value for DataView[MdocApp1.this.BundleA, MdocApp1.this.BundleB].\n// Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview\n//    out := in.viewAs[BundleB]\n//           ^^^^^^^^^^^^^^^^^^\n// error: Could not find implicit value for DataView[MdocApp1.this.BundleA, MdocApp1.this.BundleB].\n// Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview\n//    out := in.viewAs[BundleB]\n//           ^^^^^^^^^^^^^^^^^^\n// error: Could not find implicit value for DataView[MdocApp1.this.BundleB, MdocApp1.this.BundleA].\n// Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview\n//    out.viewAs[BundleA] := in\n//    ^^^^^^^^^^^^^^^^^^^\n// error: Could not find implicit value for DataProduct[MdocApp1.this.MyCounter].\n// Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview#dataproduct\n// implicit val counterView = DataView[MyCounter, Valid[UInt]](c => Valid(UInt(c.width.W)), _.value -> _.bits, _.active -> _.valid)\n//                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n")),(0,i.kt)("p",null,"As you can see, this fails Scala compliation.\nWe need to provide an implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"DataProduct[MyCounter]")," which provides Chisel a way to access\nthe objects of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," within ",(0,i.kt)("inlineCode",{parentName:"p"},"MyCounter"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import chisel3.util.Valid\nimplicit val counterProduct = new DataProduct[MyCounter] {\n  // The String part of the tuple is a String path to the object to help in debugging\n  def dataIterator(a: MyCounter, path: String): Iterator[(Data, String)] =\n    List(a.value -> s"$path.value", a.active -> s"$path.active").iterator\n}\n// Now this works\nimplicit val counterView = DataView[MyCounter, Valid[UInt]](c => Valid(UInt(c.width.W)), _.value -> _.bits, _.active -> _.valid)\n')),(0,i.kt)("p",null,"Why is this useful?\nThis is how Chisel is able to check for totality as ",(0,i.kt)("a",{parentName:"p",href:"#totality-and-partialdataview"},"described above"),".\nIn addition to checking if a user has left a field out of the mapping, it also allows Chisel to check\nif the user has included a ",(0,i.kt)("inlineCode",{parentName:"p"},"Data")," in the mapping that isn't actually a part of the ",(0,i.kt)("em",{parentName:"p"},"target")," nor the\n",(0,i.kt)("em",{parentName:"p"},"view"),"."))}c.isMDXComponent=!0}}]);